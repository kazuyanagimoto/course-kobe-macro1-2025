[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Macroeconomics I",
    "section": "",
    "text": "Syllabus",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "index.html#course-materials",
    "href": "index.html#course-materials",
    "title": "Macroeconomics I",
    "section": "Course Materials",
    "text": "Course Materials\n\n\n\n\n\n\n\n\n\nChapter\nLesson\nMain References\nAssignments\n\n\n\n\nRBC Model\n\nAzzimonti et al. (2025), Chapter 14\n2025-12-23\n\n\nNew Keynesian\n\nAscari and Rossi (2012); Galí (2015), Chapter 3\n2026-01-20\n\n\nDMP Framework\n\nAzzimonti et al. (2025), Chapter 20\n2026-01-28\n\n\n\n\n\n\n\n\n\nTipSubscribe!\n\n\n\n授業スケジュールをGoogle Calendarなどに登録できます. 私個人のために作成したものであり間違いがある可能性があります. 大学からの正式なスケジュールを優先した上で, 参考程度にご利用ください.",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "index.html#成績について",
    "href": "index.html#成績について",
    "title": "Macroeconomics I",
    "section": "成績について",
    "text": "成績について\n\n課題 (レポート) : 20%\n期末試験: 80%\n\n課題の採点について\n\n各課題の大問のうち, 課題提出後, ランダムに選ばれた大問のみ採点する\nTAセッションで行われる課題の解説は, すべての大問について行われる\n期末試験においては解答したものがすべて採点される",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "index.html#課題について",
    "href": "index.html#課題について",
    "title": "Macroeconomics I",
    "section": "課題について",
    "text": "課題について\n提出期限\n\n対応するTAセッションの前日23:59 (JST)\n例: 12月24日のTAセッション → 12月23日23:59まで\n試験期間が近いため, 第3回の課題は1月28日提出締切とし, 1月29日の授業で解説を行う\n\n提出方法\n\nGoogle Classroom 上でPDFレポートとqmdファイルをアップロード. データ等の提出の必要はない\n必要に応じて, レポートの内容が再現可能か質問することがある\n\nレポートについて\n\nPDF形式で提出. Quarto で作成されたもので, 手書きは不可\n\nレポートにコードは含めないこと\n図と表以外のコード実行のアウトプットも含めてはいけない (論文形式)\n再現性の観点から, 有料のフォント (特にMacのヒラギノ) は利用しないこと\n\nコードはJuliaを用いること\n第1, 2回のTAセッションでJuliaとQuartoの基本的な使い方を解説する\n解答にはマクロIVでのテンプレート を利用することを推奨する",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "index.html#講義資料",
    "href": "index.html#講義資料",
    "title": "Macroeconomics I",
    "section": "講義資料",
    "text": "講義資料\n授業では基本的に板書を用いるが, 必要に応じて講義資料 (このウェブサイト) も利用する. 以下のPDF版も必要に応じて利用すると良いが, 頻繁に更新される可能性があることに注意すること.\n\n\n\n\n\n\n\nAscari, Guido, and Lorenza Rossi. 2012. “Trend Inflation and Firms Price-Setting: Rotemberg Versus Calvo.” The Economic Journal 122 (563): 1115–41. https://doi.org/10.1111/j.1468-0297.2012.02517.x.\n\n\nAzzimonti, Marina, Per Krusell, Alisdair McKay, and Toshihiko Mukoyama. 2025. Macroeconomics.\n\n\nGalí, Jordi. 2015. Monetary Policy, Inflation, and the Business Cycle: An Introduction to the New Keynesian Framework and Its Applications. Second edition. Princeton Oxford: Princeton University Press.",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "01-rbc.html",
    "href": "01-rbc.html",
    "title": "1  Real Business Cycle Model",
    "section": "",
    "text": "1.1 Real Business Cycle (RBC) Model とは\nReal Business Cycle (RBC) モデルとは, 経済のビジネスサイクルを説明するためのマクロ経済学のモデルです. RBCモデルは, 経済の変動が主に技術的な要因や生産性の変化によって引き起こされると仮定しています.\nこれまで学んだRamseyモデルでも, 貨幣や名目変数を考慮しない, つまりRealなモデルでした. また, Ramseyモデルでも, 生産性 (TFP) の成長を考慮していました. RBCモデルでは, TFPの成長を確率的なもの (stochastic) なものとして考えます. まとめると以下のようになります.\n\\[\n\\text{RBC Model} = \\text{Ramsey Model} + \\text{Stochastic TFP}.\n\\]\nRBCモデルへの主要な貢献に対してKydlandとPrescottが2004年にノーベル経済学賞を受賞しています (図 1.1).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>RBC Model</span>"
    ]
  },
  {
    "objectID": "01-rbc.html#real-business-cycle-rbc-model-とは",
    "href": "01-rbc.html#real-business-cycle-rbc-model-とは",
    "title": "1  Real Business Cycle Model",
    "section": "",
    "text": "Real: 貨幣や他の名目変数を考慮しない\nBusiness Cycle: 長期的なトレンド (成長) と短期的な変動を考慮する\n\n\n\n\n\n\n\n\n\n\n図 1.1: Nobel Prize in Economic Science 2004.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>RBC Model</span>"
    ]
  },
  {
    "objectID": "01-rbc.html#sec-facts",
    "href": "01-rbc.html#sec-facts",
    "title": "1  Real Business Cycle Model",
    "section": "1.2 Stylized Facts",
    "text": "1.2 Stylized Facts\n\n1.2.1 トレンドとサイクル\nLucas (1977) や Kydland and Prescott (1982) は景気循環をトレンドとサイクルに分けて考えることを提案しました. トレンドは長期的な成長を表し, サイクルは短期的な変動を表します.\n\n\n\n\n\n\n図 1.2: Stylized Representation of Business Cycle\n\n\n\n図 1.2 のように景気循環とは, 成長トレンドの周りにPeakとTroughを持つ波のような動きととらえます. 特に, PeakからTroughまでの期間を不景気 (recession) と呼び, TroughからPeakまでの期間を好景気 (boom, expansion) と呼びます.\n\n\n\n\n\n\n図 1.3: U.S. Bureau of Economic Analysis, Real Gross Domestic Product GDPC1.\n\n\n\n例えば, アメリカの実質GDPの時系列データを見てみましょう (図 1.3). アメリカの実質GDPは成長傾向をもちながらも短期的な変動を繰り返しています. 特にグレーの部分は不景気を示しており, National Bureau of Economic Research (NBER) の Business Cycle Dating Committee が様々な経済指標を用いて, アメリカが不景気にあるかを定義しています.\n\n\n1.2.2 Hodrick and Prescott Filter\nHodrick-Prescott (HP) フィルターは, 時系列データからトレンド成分とサイクル成分を分離するための手法です.\n\n\n\n\n\n\nNoteHodrick and Prescott Filter\n\n\n\n時系列データ \\(\\{Y\\}_{t=0}^T\\) に対して, HPフィルターは以下の最適化問題を解くことでトレンド成分 \\(\\{\\tau_t\\}\\) を求める.\n\\[\n\\min_{\\{\\tau_t\\}} \\sum_{t=1}^{T} \\left(Y_t - \\tau_t\\right)^2 +\n\\lambda \\left[\\sum_{t=2}^{T-1} \\left((\\tau_{t+1} - \\tau_t) - (\\tau_t - \\tau_{t-1})\\right)^2\\right]\n\\tag{1.1}\\]\nここで平滑化パラメータ \\(\\lambda\\) は四半期データなら \\(1600\\), 年次データなら \\(100\\) が一般的に用いられる.\n\n\n直感的にはある程度スムーズなトレンド成分を求めるために, トレンド成分の符号の反転に大きくペナルティを欠けているというイメージです. 図 1.4 を見ると, 符号が反転するような \\(\\tau_t\\) の取り方はペナルティが大きくなり, そのような \\(\\tau_t\\) が選ばれにくいことがわかります.\n\n\n\n\n\n\n図 1.4: Example of Large Penalty in HP Filter\n\n\n\n一方で, 図 1.5 は, 符号が反転しにくい \\(\\tau_t\\) の取り方はペナルティが小さくなり, そのような \\(\\tau_t\\) が選ばれやすいことを示しています. 今回の例では, \\(y_t\\) が上昇傾向にあるように見えるので, 一定のペースで上昇するような \\(\\tau_t\\) が選ばれやすくなっています.\n\n\n\n\n\n\n図 1.5: Example of Small Penalty in HP Filter\n\n\n\nこの異符号に対する大きなペナルティは, 式 1.1 のペナルティ項を展開して見ると違いがよく分かります.\n\\[\n\\begin{aligned}\n&\\sum_{t=2}^{T-1} \\left((\\tau_{t+1} - \\tau_t) - (\\tau_t - \\tau_{t-1})\\right)^2 \\\\\n&= \\sum_{t=2}^{T-1} (\\tau_{t+1} - \\tau_t)^2 + \\sum_{t=2}^{T-1} (\\tau_t - \\tau_{t-1})^2 - 2\\sum_{t=2}^{T-1} (\\tau_{t+1} - \\tau_t)(\\tau_t - \\tau_{t-1}) \\\\\n&= \\underbrace{(\\tau_{T} - \\tau_{T-1})^2 + 2\\sum_{t=2}^{T-1} (\\tau_t - \\tau_{t-1})^2}_{\\text{Penalty for large difference}} \\underbrace{- 2\\sum_{t=2}^{T-1} (\\tau_{t+1} - \\tau_t)(\\tau_t - \\tau_{t-1})}_{\\text{Penalty for sign change}}.\n\\end{aligned}\n\\]\n最初の項は, トレンド成分の変化が大きい場合にペナルティを課すものであり, 2番目の項はトレンド成分の符号が反転する場合にペナルティを課すものです. そのため, 符号が反転しにくいようなトレンド成分が選ばれやすくなります.\nHP Filter の実践\n図 1.6 は, アメリカの実質GDPの時系列データにHPフィルターを適用した結果です. Juliaでは, QuantEcon.hp_filter 関数を用いてHPフィルターを適用できます.\n\n\nCode\ndata = CSV.read(@projectroot(\"data\", \"fred_data.csv\"), DataFrame; missingstring=\"NA\")\n\nfunction plot_trend(var, title; data=data, λ=1600, legend=false)\n    xs = log.(data[!, var])\n    cycle, trend = hp_filter(xs, λ)\n\n    years = unique(year.(data.date))\n    year_ticks = [Date(y, 1, 1) for y in years[1:15:end]]\n    year_labels = [string(y) for y in years[1:15:end]]\n\n    p = plot(data.date, trend, label=\"HP trend\", title=title, legend=legend,\n        xticks=(year_ticks, year_labels))\n    plot!(p, data.date, xs, label=\"Data\")\n    return p\nend\n\np1 = plot_trend(\"gdp\", \"Real GDP\", legend=:topleft)\np2 = plot_trend(\"consumption\", \"Consumption\")\np3 = plot_trend(\"labor\", \"Labor Hours\")\np4 = plot_trend(\"investment\", \"Investment\")\n\nplot(p1, p2, p3, p4, layout=(2, 2))\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 1.6: Data and Trend of Logs of U.S. Aggregates. Quartely Data 1948I-2025III from FRED. HP filter with \\(\\lambda = 1600\\).\n\n\n\n\n\n\nCode\nfunction plot_cycle(var, title; data=data, λ=1600, legend=false)\n    xs = log.(data[!, var])\n    cycle, trend = hp_filter(xs, λ)\n\n    years = unique(year.(data.date))\n    year_ticks = [Date(y, 1, 1) for y in years[1:15:end]]\n    year_labels = [string(y) for y in years[1:15:end]]\n\n    p = plot(data.date, cycle, label=false, title=title, legend=legend,\n        xticks=(year_ticks, year_labels))\n\n    cycle_gdp, _ = hp_filter(log.(data[!, \"gdp\"]), λ)\n    plot!(p, data.date, cycle_gdp, label=\"GDP cycle\")\n    return p\nend\n\np1 = plot_cycle(\"gdp\", \"Real GDP\", legend=:bottomleft)\np2 = plot_cycle(\"consumption\", \"Consumption\")\np3 = plot_cycle(\"labor\", \"Labor Hours\")\np4 = plot_cycle(\"investment\", \"Investment\")\n\nplot(p1, p2, p3, p4, layout=(2, 2))\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 1.7: GDP Cycle and Other Cycles. Data from FRED. HP filter with \\(\\lambda = 1600\\).\n\n\n\n\n図 1.7 は, Real GDP のサイクル成分と他の経済変数のサイクル成分を比較したものです. これを見ると消費と労働時間のサイクル成分はGDPのサイクル成分と似た動きをしていることがわかります. 一方で, 投資のサイクル成分はGDPのサイクル成分よりも変動が大きいことがわかります.\nなお, HPフィルターは慣例的に用いられている手法ですが\n\n\\(\\lambda\\) の選び方によって結果が変わる\nHPフィルターの関数形に経済学的な裏付けがない\n\nなどの問題点があるため, Band Pass Filter (Baxter and King 1999) など他の手法も検討されています.\n\n\n1.2.3 景気循環統計\nRBCモデルの研究では, 景気循環の特徴を定量的に評価するために, 2次モーメントを計算します. 具体的には, 各経済変数の標準偏差, 自己相関係数, 相関係数を計算します. (1次モーメントである平均は, トレンド成分を除去した後はゼロになるため, 特に計算する必要はありません.) ここでは時系列データに対して, 対数をとりHPフィルターを適用した後に, 各経済変数の2次モーメントを計算します.\n\nCode\nλ = 1600\ngdp_cycle, _ = hp_filter(log.(data[!, \"gdp\"]), λ)\ncons_cycle, _ = hp_filter(log.(data[!, \"consumption\"]), λ)\ninv_cycle, _ = hp_filter(log.(data[!, \"investment\"]), λ)\nlabor_cycle, _ = hp_filter(log.(data[!, \"labor\"]), λ)\n\ncycles = [gdp_cycle, cons_cycle, inv_cycle, labor_cycle]\n\ndf_data = DataFrame(\n    pars=[\"GDP\", \"Consumption\", \"Investment\", \"Labor Hours\"],\n    std=100 .* std.(cycles),\n    std_rel=std.(cycles) ./ std(gdp_cycle),\n    acor=[cor(cycle[begin:end-1], cycle[begin+1:end]) for cycle in cycles],\n    cory=[cor(gdp_cycle, cycle) for cycle in cycles]\n)\n\npretty_table(\n    df_data,\n    alignment=[:l, :r, :r, :r, :r],\n    column_labels=[\"Variable\", \"Std. Dev. (%)\", \"SD rel. to GDP\",\n        \"Autocorrelation\", \"Corr. with GDP\"],\n    backend=:markdown,\n    allow_markdown_in_cells=true,\n    formatters=[(v, i, j) -&gt; v isa Number ? @sprintf(\"%.3f\", v) : v]\n)\n\n\n\n\n表 1.1: Business Cycle Statistics from U.S. Data 1948I-2025II.\n\n\n\n\n\n\n\n\n\n\n\n\nVariable\nStd. Dev. (%)\nSD rel. to GDP\nAutocorrelation\nCorr. with GDP\n\n\n\n\nGDP\n1.649\n1.000\n0.788\n1.000\n\n\nConsumption\n1.356\n0.822\n0.708\n0.797\n\n\nInvestment\n7.034\n4.266\n0.790\n0.837\n\n\nLabor Hours\n2.081\n1.262\n0.818\n0.869",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>RBC Model</span>"
    ]
  },
  {
    "objectID": "01-rbc.html#model",
    "href": "01-rbc.html#model",
    "title": "1  Real Business Cycle Model",
    "section": "1.3 Model",
    "text": "1.3 Model\n\n1.3.1 設定\n\n経済は一人の代表的消費者からなる\n効用 \\(U(c, l)\\) は消費 \\(c\\) と余暇 \\(l\\) の関数\n消費者は一単位の時間をもち, 労働 \\(n\\) と余暇 \\(l\\) を選択する (\\(n + l = 1\\))\n離散時間を仮定し, 期待効用最大化問題を解く\n\n\\[\n\\mathbb{E}_0 \\sum_{t=0}^{\\infty} \\beta^t U(c_t, l_t).\n\\]\n生産関数\n\n\\(Y_{t} = z_t F(k_t, n_t)\\)\n\\(z_t\\) は生産性 (TFP) であり以下のAR(1)過程に従う (詳細は Section C.1)\n\n\\[\n\\log z_t = \\rho_z \\log z_{t-1} + \\sigma_z \\varepsilon_t, \\quad \\varepsilon_t \\sim N(0, 1).\n\\]\n資本蓄積\n\\[\nk_{t+1} = (1-\\delta) k_t + i_t\n\\tag{1.2}\\]\n\n\\(k_t\\) は資本ストック, \\(i_t\\) は投資, \\(\\delta\\) は減耗率\n\n予算制約\n\\[\nc_t + i_t = z_t F(k_t, n_t).\n\\]\n\n\n1.3.2 ベルマン方程式\n上記の生産関数, 資本蓄積, 予算制約を元の効用最大化問題に組み込むと, 以下の問題が導けます.\n\\[\nV(k_0, z_0) = \\max_{\\{k_{t+1}(z_t), n_t(z_t)\\}_{t=0}^{\\infty}} \\mathbb{E}_0 \\sum_{t=0}^{\\infty} \\beta^t U(z_tF(k_t, n_t) + (1-\\delta)k_t - k_{t+1}, 1 - n_t).\n\\]\nここで, \\(t=0\\) の時点では, \\(k_0\\) と \\(z_0\\) が与えられています. また, \\(k_{t+1}, n_{t}\\) が \\(z_t\\) の実現値に依存していることに注意してください. \\(t=0\\) 時点で決定している変数に着目すると\n\\[\n\\begin{aligned}\n&V(k_0, z_0) = \\max_{k_1, n_0} U(z_0F(k_0, n_0) + (1-\\delta)k_0 - k_1, 1 - n_0) \\\\\n&+ \\beta \\mathbb{E}_{z_1}\\left[\n\\underbrace{\\max_{\\{k_{t+2}(z_{t+1}), n_{t+1}(z_{t+1})\\}_{t=0}^{\\infty}} \\mathbb{E}_1 \\sum_{t=0}^{\\infty} \\beta^{t} U(z_{t+1}F(k_{t+1}, 1 - n_{t+1}) + (1-\\delta)k_{t+1} - k_{t+2}, 1 - n_{t+1})}_{V(k_1, z_1)}\\middle| z_0 \\right].\n\\end{aligned}\n\\]\nここで \\(t=0\\) の時点では \\(z_1\\) の実現値は分からず, 期待値をとっている点に注意してください. これをまとめると以下のようなベルマン方程式が得られます.\n\\[\nV(k, z) = \\max_{k', n} U\\left(zF(k, n) + (1-\\delta)k - k', 1-n\\right) + \\beta \\mathbb{E}[V(k', z') | z].\n\\]\n最適条件\n価値関数 \\(V(k, z)\\) の微分可能性を仮定し, 効用最大化問題の一階条件を求める. \\(k'\\) に関する一階条件は\n\\[\nU_1(c, 1 - n) = \\beta \\mathbb{E}[V_{1}(k', z') | z].\n\\tag{1.3}\\]\n\\(n\\) に関する一階条件は\n\\[\nz F_{2}(k, n) = \\frac{U_{2}(c, 1 - n)}{U_{1}(c, 1 - n)}.\n\\tag{1.4}\\]\n\\(k\\) に関する Envelope 条件を求めると\n\\[\nV_{1}(k, z) = (zF_{1}(k, n) + 1-\\delta) U_1(c, 1 - n).\n\\tag{1.5}\\]\nここで, 式 1.3 と 式 1.5 から,\n\\[\nU_{1}(c, 1 - n) = \\beta \\mathbb{E}[(z F_{1}(k', n') + 1 - \\delta)U_{1}(c', 1 - n') | z].\n\\tag{1.6}\\]\nIntratemporal and Intertemporal Optimal Conditions\n式 1.4 と 式 1.6 の2本の式がRBCモデルを特徴づける式です. 式 1.4 は同時点 (Intratemporal) での最適条件, 式 1.6 は異時点 (Intertemporal) での最適条件を表し, オイラー方程式とも呼ばれます.\n\n式 1.4 は消費と余暇の間の限界代替率 (MRS) が労働の限界生産性 (MPL) に等しいことを示しています\n式 1.6 は, 消費の限界効用が, 将来の消費の限界効用の期待値と割引率の積に等しいことを示しています",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>RBC Model</span>"
    ]
  },
  {
    "objectID": "01-rbc.html#calibration",
    "href": "01-rbc.html#calibration",
    "title": "1  Real Business Cycle Model",
    "section": "1.4 Calibration",
    "text": "1.4 Calibration\n\n1.4.1 RBCモデルにおける標準的なパラメータ\nRBCモデルの研究では, 以下のパラメータが慣例的に用いられます. その多くを Kydland and Prescott (1982), Prescott (1986) または Cooley and Prescott (1995) から引用しています.\n\n\n\n表 1.2: Standard RBC model parameters. Quarterly frequency.\n\n\n\n\n\n\n\n\n\n\n\nParameter\nDescription\nPrescott (1986)\nCooley and Prescott (1995)\n\n\n\n\n\\(\\beta\\)\n割引率\n0.99\n0.987\n\n\n\\(\\sigma\\)\n効用関数の曲率\n1.0\n1.0\n\n\n\\(\\phi\\)\n効用関数の余暇の重み\n0.66\n0.64\n\n\n\\(\\alpha\\)\n資本のシェア\n0.36\n0.4\n\n\n\\(\\delta\\)\n資本の減耗率\n0.025\n0.012\n\n\n\\(\\rho_z\\)\nTFPの自己回帰係数\n0.9\n0.95\n\n\n\\(\\sigma_z\\)\nTFPのショックの標準偏差\n0.007\n0.007\n\n\n\n\n\n\nなお, Prescott (1986) は年率であるため, 四半期率への変換は以下のように行なっています.\n\n\\(\\beta_{\\text{quarter}} = \\beta_{\\text{year}}^{\\frac{1}{4}} = 0.96^{\\frac{1}{4}} \\approx 0.99\\)\n\\(\\delta_{\\text{quarter}} = 1 - (1 - \\delta_{\\text{year}})^{\\frac{1}{4}} = 1 - (1 - 0.1)^{\\frac{1}{4}} \\approx 0.025\\)\n\n注意しなければならないのは, これらの数字は当時のアメリカ経済に基づいているため, 異なる国や時代では異なる値を取る可能性があるということです.\n\n\n1.4.2 標準的なパラメータの導出\nRBCモデルやその派生となるモデルも上記のパラメータ値が使われることが多いですが, これらのパラメータの導出方法を知っておくことは重要です.\n資本分配率 \\(\\alpha\\)\nCobb-Douglas型の生産関数を仮定した時の, 労働分配率 (Labor share) \\(\\frac{wN}{Y}\\) は \\(1-\\alpha\\) と表せます. これは, 均衡において, 労働の限界生産性 (MPL) が賃金 (wage) に等しいことから導かれます.\n\\[\nw = \\frac{\\partial Y}{\\partial N} = (1 - \\alpha) \\frac{Y}{N}.\n\\]\n\n\n\n\n\n\n図 1.8: Declining Labor Share for the Largest Countries. Figure 2 in Karabarbounis and Neiman (2014).\n\n\n\n図 1.8 を見ると, アメリカでは2000年までは労働分配率はおおむね 0.64 であったことがわかります. そのため, Prescott (1986) のように資本分配率は \\(0.36\\) と導けます. ただし, グラフからも分かるように近年は労働分配率が減少しているため, この仮定を使うことは難しくなってきています.\n資本の減耗率 \\(\\delta\\)\n資本減耗率は Kydland and Prescott (1982) のモデルにおける定常状態から推定した年率 \\(0.1\\) (四半期換算で0.025) が用いられることが多いです. Kydland and Prescott (1982) のモデルは今回紹介したモデルと少し異なるため, Cooley and Prescott (1995) の方法を紹介します.\nCooley and Prescott (1995) のモデルでは, 生産関数に外生的な成長率 \\(\\gamma\\) を導入しています. 式 1.2 を \\(y_t\\) で割ると,\n\\[\n\\frac{y_{t+1}}{y_t}\\frac{k_{t+1}}{y_{t+1}} = (1-\\delta) \\frac{k_t}{y_t} + \\frac{i_t}{y_t} \\Rightarrow\n(1+\\gamma) \\frac{k_{t+1}}{y_{t+1}} = (1-\\delta) \\frac{k_t}{y_t} + \\frac{i_t}{y_t}\n\\]\n定常状態では,\n\\[\n(1+\\gamma) \\frac{k}{y} = (1-\\delta) \\frac{k}{y} + \\frac{i}{y} \\Rightarrow \\frac{i}{k} = (\\gamma + \\delta).\n\\]\n長期の投資資本比率 \\(\\frac{i}{k} = 0.076\\)1, 成長率 \\(\\gamma = 0.028\\) を用いて, \\(\\delta = 0.048\\) (年率) を導出できます. 四半期換算すると, \\(\\delta = 0.012\\) です. 図 1.9 は, アメリカの実質GDPの成長率であり \\(\\gamma = 0.028\\) がおおむね妥当な値であることが分かります.\n\n\nCode\ngmd = CSV.read(@projectroot(\"data\", \"gmd_data.csv\"), DataFrame; missingstring=\"NA\")\n\ndata_filtered = filter(row -&gt; row.year &gt;= 1950, gmd)\nplot(data_filtered.year, data_filtered.rate_growth, label=false, size=(500, 309),\n    ylabel=\"Growth Rate (%)\")\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 1.9: Growth Rate of Real GDP in the US. Data from Müller et al. (2025).\n\n\n\n\n効用関数の曲率 (Curvature) \\(\\sigma\\)\n戦後のアメリカでは以下の現象が見られました.\n\n実質賃金は一定割合で上昇している (Balanced growth path)\n消費も一定割合で上昇している\n労働時間はおおむね一定である\n\nKing, Plosser, and Rebelo (1988) はBalanced growth path と労働時間一定を仮定した場合, 効用関数の形状は以下のように制約されることを示しました. (KPR型効用関数)\n\\[\nu(c, l) = \\frac{(c v(l))^{1-\\sigma} - 1}{1 - \\sigma}.\n\\]\nここで, \\(v(\\cdot)\\) は strictly increasing, strictly concave, \\(v'(0) = -\\infty\\) を満たす関数です. \\(\\sigma\\) の値に関しては多くの先行研究がありますが, 一般に決定するのは難しいです. ここでは最も単純な形として \\(\\sigma = 1\\) を仮定し, \\(v(l) = l^{\\frac{\\phi}{1-\\phi}}, 0 &lt; \\phi &lt; 1\\) を仮定します. これにより, 効用関数は以下のようになります.2\n\\[\nu(c, l) = (1-\\phi) \\log c + \\phi \\log l.\n\\tag{1.7}\\]\nなお, 労働時間が一定であるという点は近年の研究では問題視されています. Boppart and Krusell (2020) は, balanced growth path 上で, 労働時間が減少することを許容した効用関数を提案しています.\n\n\n\n\n\n\n図 1.10: Selected countries’ average annual hours per capita aged 15-64, 1950-2015. Figure 3 in Boppart and Krusell (2020)\n\n\n\n\n“The absence of a trend in hours worked in the postwar United States is an exception.” — Boppart and Krusell (2020)\n\n効用関数の余暇の重み \\(\\phi\\)\nこのパラメータの推定値は研究によってブレがあります. 以下では簡単な数値例を示します.\n式 1.7 を 式 1.4 に代入することで, 以下の式が導けます.\n\\[\n\\frac{\\phi}{1-\\phi}\\frac{n_t}{1-n_t} = (1-\\alpha)\\frac{y_t}{c_t}\n\\]\n\n1日に8時間労働をするとして, \\(n_t = \\frac{8}{24} = \\frac{1}{3}\\).\n最も単純な形の労働分配率として \\(1 - \\alpha = \\frac{2}{3}\\)\nGDPに締める消費の割合 (BGP上では定数) として, \\(\\frac{c_t}{y_t} = \\frac{3}{4}\\)\n\nCooley and Prescott (1995) の値に近い\n図 1.11 と比べるとやや小さい値である.3\n\n\nこれらを計算すると, \\(\\phi = \\frac{16}{25} = 0.64\\) が得られ, おおむね Prescott (1986) や Cooley and Prescott (1995) の値と一致します. ここでは, Azzimonti et al. (2025) の推定結果である \\(\\phi = 0.6325\\) を用います.\n\n\nCode\nplot(data.date, data.consumption ./ data.gdp, label=false, ylabel=\"Ratio C/Y\",\n    size=(500, 309))\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 1.11: Share of Consumption to GDP in the US. Data from FRED.\n\n\n\n\nAR(1) 過程 \\(\\rho_z, \\sigma_z\\)\n生産関数の関数形から次の関係式が導けます.\n\\[\n\\log z_t = \\log y_t - \\alpha \\log k_t - (1-\\alpha) \\log n_t.\n\\]\n上で仮定したように \\(\\alpha\\) の値を定めると, \\(z_t\\) の時系列データが得られます. そこから, 分散と自己相関を計算することで, \\(\\rho_z\\), \\(\\sigma_z\\) の値を推定できます. ここでは, Cooley and Prescott (1995) の値 \\(\\rho_z = 0.95\\), \\(\\sigma_z = 0.007\\) を用います.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>RBC Model</span>"
    ]
  },
  {
    "objectID": "01-rbc.html#simulation",
    "href": "01-rbc.html#simulation",
    "title": "1  Real Business Cycle Model",
    "section": "1.5 Simulation",
    "text": "1.5 Simulation\n\n1.5.1 MacroModelling.jl によるシミュレーション\nRBCモデルのシミュレーションを行います. シミュレーション1から実装するためには, プログラミングや線形代数の基礎知識が必要ですが, RBCやDSGEなどの有名なマクロモデルはそのシミュレーションを自動化するパッケージが数多く存在します. ここでは, Julia の MacroModelling.jl パッケージを用います. なお, 歴史的には (現在でも) Matlab の Dynare パッケージが広く使われていますが, Matlabを利用するにはライセンス料がかかります.\n\\[\n\\begin{aligned}\n\\phi\\frac{1}{1-n_t} &= (1-\\phi)\\frac{z_t (1-\\alpha)k_t^{\\alpha} n_t^{-\\alpha}}{c_t} \\\\\n\\frac{1-\\phi}{c_t} &= \\beta \\mathbb{E}\\left[\\frac{(1-\\phi)(z_{t+1}\\alpha k_{t+1}^{\\alpha-1}n_{t+1}^{1-\\alpha} + 1-\\delta)}{c_{t+1}}\\middle| z_t\\right] \\\\\nk_{t+1} &= (1-\\delta)k_t + z_t k_t^{\\alpha} n_t^{1-\\alpha} - c_t \\\\\n\\log z_{t+1} &= \\rho_z \\log z_t + \\sigma_z \\varepsilon_{t}\n\\end{aligned}\n\\tag{1.8}\\]\nMacroModelling.jl では上記のモデルを以下のように, ほとんどそのまま記述できます. 一つ注意点としては, \\(t\\) 時点ですでに決定されている変数 (\\(k_t, z_t\\)) は \\(t-1\\) 時点の変数として記述する必要があるということです. また, 後にIRFをプロットするために, investment \\(i_t\\) と output \\(y_t\\) は明示的にモデルの中で定義する必要があります.\n\n@model RBC begin\n    ϕ / (1 - n[0]) = (1 - ϕ) * ((1 - α) * y[0] / n[0]) / c[0]\n    (1 - ϕ) / c[0] = β * (1 - ϕ) * (α * y[1] / k[0] + 1 - δ) / c[1]\n    k[0] = (1 - δ) * k[-1] + i[0]\n    y[0] = z[0] * k[-1]^α * n[0]^(1 - α)\n    i[0] = y[0] - c[0]\n    log(z[0]) = ρ_z * log(z[-1]) + σ_z * ε[x]\nend\n\n@parameters RBC begin\n    β = 0.99\n    ϕ = 0.6325\n    α = 0.36\n    δ = 0.025\n    ρ_z = 0.95\n    σ_z = 0.007\nend\n\nRemove redundant variables in non-stochastic steady state problem:  1.026 seconds\nSet up non-stochastic steady state problem:             9.953 seconds\nFind non-stochastic steady state:                   1.707 seconds\nTake symbolic derivatives up to first order:                3.692 seconds\nModel:        RBC\nVariables\n Total:       6\n  Auxiliary:  0\n States:      2\n  Auxiliary:  0\n Jumpers:     2\n  Auxiliary:  0\nShocks:       1\nParameters:   6\n\n\nここで行われているのは以下の3つのステップです.\n\nVariable の認識\nNon-stochastic steady state の計算\n線形化 (一次近似)\n\nモデル上のパラメータ数が6 (y, c, k, n, z, i) であること, 状態変数が2つ (k, z) であること, ジャンプ変数が2つであること (c, n) であること, ショックが1つであること (ε) が正しく認識されています. 線形化および一次近似はここでは立ち寄らず, Chapter 2 で詳しく説明します.\nNon-stochastic Steady State\nNon-stochastic steady state はその名の通り, ショックが存在しない場合の定常状態を指します. 具体的には 式 1.8 の式を用いて, 以下の連立方程式を解きます.\n\\[\n\\begin{aligned}\n\\phi\\frac{1}{1-n} &= (1-\\phi)\\frac{(1-\\alpha)k^{\\alpha} n^{-\\alpha}}{c} \\\\\n\\frac{1-\\phi}{c} &= \\beta \\left[\\frac{(1-\\phi)( \\alpha k^{\\alpha-1}n^{1-\\alpha} + 1-\\delta)}{c}\\right] \\\\\nk &= (1-\\delta)k + z k^{\\alpha} n^{1-\\alpha} - c \\\\\n\\log z &= \\rho_z \\log z + \\sigma_z \\cdot 0\n\\end{aligned}\n\\tag{1.9}\\]\n今回のような単純なモデルでは, 解析解を求めることが可能ですが, 一般的には解析解がないため, 数値的に解く必要があります. MacroModelling.jl では, get_steady_state 関数を用いて簡単に計算できます.\n\nget_steady_state(RBC)\n\n\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n↓   Variables_and_calibrated_parameters ∈ 6-element Vector{Symbol}\n→   Steady_state_and_∂steady_state∂parameter ∈ 7-element Vector{Symbol}\nAnd data, 6×7 Matrix{Float64}:\n        (:Steady_state)   (:β)      …    (:δ)       (:ρ_z)  (:σ_z)\n  (:c)   0.918207         11.9452       -15.9294     0.0     0.0\n  (:i)   0.316611         16.4954        -0.591578   0.0     0.0\n  (:k)  12.6644          659.814       -530.24       0.0     0.0\n  (:n)   0.333369          2.22744        0.882066   0.0     0.0\n  (:y)   1.23482          28.4405   …   -16.5209     0.0     0.0\n  (:z)   1.0               0.0            0.0        0.0     0.0\n\n\n\nここでは, steady state の値の他に, 各パラメータに対する偏微分も計算されています. 例えば, 余暇のウェイトである \\(\\phi\\) の増加に対して, 消費 \\(c\\) や労働 \\(n\\) が減少することがわかります.\nSimulation\nこのモデルは以下のように簡単にシミュレーションできます.\n\nplot_simulation(RBC, periods=150);\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\nここでいうシミュレーションとは\n\n初期値を与える. ここでは steady state の値\nショックを与える. ここでは TFPショック \\(\\varepsilon_t \\sim \\mathcal{N}(0, 1)\\) を毎期与える\n\n各経済変数が相関を持ちながら変化していく様子が見て取れます. 次節ではより詳しく評価を行います.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>RBC Model</span>"
    ]
  },
  {
    "objectID": "01-rbc.html#evaluation",
    "href": "01-rbc.html#evaluation",
    "title": "1  Real Business Cycle Model",
    "section": "1.6 Evaluation",
    "text": "1.6 Evaluation\n\n1.6.1 Impulse Response Function (IRF)\nImpulse Response Function (IRF) は, ショックに対する経済変数の応答を示すグラフです. RBCモデルでは, TFPショックに対する経済変数の応答を調べることが一般的です. 具体的には\n\n\\(t = 0\\) の時点で TFP ショック \\(\\varepsilon_{t} = 1\\) を与える\n\\(t = 1\\) 以降の時点で TFP ショックはゼロに戻す. \\(\\varepsilon_{t} = 0\\)\nショック後の経済変数がどう steady state に収束していくかを調べる\n\nMacroModelling.jl では, plot_irf 関数を用いてIRFをプロットできます.\n\nplot_irf(RBC, periods=150);\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\nモデルを理解する上で, それぞれの経済変数の変化を言語化することが大切です.\n\n\\(z_t\\): TFPショックにより, 生産性が一時的に上昇した後, \\(\\rho_{z}\\) に従って減少していく\n\\(y_t\\): TFPショックにより生産性が上昇し, 生産量も一時的に増加する. その後, TFPの減少に伴い生産量も減少していく\n\\(c_t\\): 生産の上昇に伴い (恒常所得仮説に従って緩やかに) 消費が増加する. その後, 生産の減少に伴い消費も減少していく\n\\(n_t\\): TFPショックにより, 労働の限界生産性が上昇し, 即座に労働供給が増加する. その後, 豊かになった家計は余暇を増やすために労働供給を減少させる\n\\(i_t\\): TFPショックにより, 資本の限界生産性が上昇し, 即座に投資が増加する. その後, 生産性の減少に伴い投資も減少していく\n\\(k_t\\): 資本はストック変数であるため, フローである投資 \\(i_t\\) の変化に応じて徐々に変化する\n\n\\(\\rho_z\\) の役割\n\n\nCode\nT = 150\nirfs = [\n    get_irf(RBC, periods=T, parameters=(:ρ_z =&gt; ρ_z)) ./\n    collect(get_steady_state(RBC, parameters=(:ρ_z =&gt; ρ_z)))[:, 1]\n    for ρ_z in (0.95, 0.9, 0.5)\n]\n\nps = Array{Plots.Plot,1}(undef, 4)\nfor (i, (idx, title)) in enumerate((\n    (5, L\"Output $(y_t)$\"), (1, L\"Consumption $(c_t)$\"),\n    (6, L\"TFP $(z_t)$\"), (4, L\"Labor $(n_t)$\")\n))\n    ps[i] = plot(1:T, 100 .* irfs[1][idx, :, 1], label=L\"\\rho_z=0.95\",\n        ylabel=\"% deviation from SS\",\n        title=title,\n        ylabelfontsize=8)\n    plot!(ps[i], 1:T, 100 .* irfs[2][idx, :, 1], label=L\"\\rho_z=0.9\", linestyle=:dash)\n    plot!(ps[i], 1:T, 100 .* irfs[3][idx, :, 1], label=L\"\\rho_z=0.5\", linestyle=:dot)\nend\n\nplot(ps..., layout=(2, 2))\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 1.12: IRFs with Different TFP Persistence \\(\\rho_z\\).\n\n\n\n\nRBCモデルでは, TFPショックの自己回帰係数 \\(\\rho_z\\) が重要な役割を果たします. \\(\\rho_z\\) が大きいほど, ショックの影響が長く続くことを意味します. \\(y_t\\) は \\(z_t\\) に強く依存するため, \\(\\rho_z\\) が大きいほど \\(y_t\\) の増加も長く続きます. また, 消費をスムーズにする働きから, \\(c_t\\) の変化は \\(y_t\\) より緩やかになります. 生産性の変化が長く続かないと予期している家計は, 初期の高い生産性を活かすために労働供給を増加させます. そのため, \\(\\rho_z\\) が小さいほど \\(n_t\\) の初期反応が大きくなります.\n\n\n1.6.2 景気循環統計\nSection 1.2 でみた, 景気循環の特徴を定量的に評価するために, シミュレーション結果から2次モーメントを計算します. 具体的には, 各経済変数の標準偏差, 自己相関係数, 相関係数を計算します. ポイントとしては\n\nシミュレーションのバーンイン期間 (burn-in period) を設ける. ここでは100期間\nシミュレーションの期間は実際のデータと同じ140期間\n各経済変数の対数をとり, 周期成分をHPフィルターで抽出する. ここでは四半期データを想定して, \\(\\lambda = 1600\\) を使用\n各経済変数の標準偏差, 自己相関係数, 相関係数を計算する\nシミュレーションを複数回行い, 結果を平均化する. ここでは250回のシミュレーションを行う\n\nここで大事なのは, シミュレーションの結果を実際のデータと同じように扱うと言うことです. そのため, 対数をとりHPフィルターを適用しています.\n\nCode\nfunction sim_one(; burnin, periods, mdl=RBC, parameters=(:ρ_z =&gt; 0.95))\n    sim = get_simulation(mdl, periods=periods + burnin, levels=true,\n        parameters=parameters)\n    cs = sim[1, burnin+1:end]\n    is = sim[2, burnin+1:end]\n    ns = sim[4, burnin+1:end]\n    ys = sim[5, burnin+1:end]\n    zs = sim[6, burnin+1:end]\n\n    cycles = [hp_filter(log.(xs), 1600)[1] for xs in (ys, cs, is, ns, zs)]\n\n    std_mdl = [std(xs) for xs in cycles]\n    acor_mdl = [cor(xs[2:end], xs[1:end-1]) for xs in cycles]\n    cory_mdl = [cor(xs, cycles[1]) for xs in cycles]\n\n    df = DataFrame(\n        pars=[\"y\", \"c\", \"i\", \"n\", \"z\"],\n        std=100 .* std_mdl,\n        std_rel=std_mdl ./ std_mdl[1],\n        acor=acor_mdl,\n        cory=cory_mdl\n    )\nend\n\nfunction get_table(; n_sim=250, burnin=100, periods=140)\n    df = sim_one(burnin=burnin, periods=periods)\n    for i in 2:n_sim\n        df_i = sim_one(burnin=burnin, periods=periods)\n        df = vcat(df, df_i)\n    end\n\n    result = combine(groupby(df, :pars),\n        [:std, :std_rel, :acor, :cory] .=&gt; mean .=&gt; [:std, :std_rel, :acor, :cory]\n    )\n    return result\nend\n\ndf_mdl = get_table()\ndf_mdl.pars = [\"Output\", \"Consumption\", \"Investment\", \"Labor\", \"TFP\"]\n\npretty_table(\n    df_mdl,\n    column_labels=[\"Variable\", \"Std. Dev. (%)\", \"SD rel. to GDP\",\n        \"Autocorrelation\", \"Correlation with GDP\"],\n    backend=:markdown,\n    allow_markdown_in_cells=true,\n    formatters=[(v, i, j) -&gt; v isa Number ? @sprintf(\"%.3f\", v) : v]\n)\n\n\n\n\n表 1.3: Business Cycle Statistics from RBC Model\n\n\n\n\n\n\n\n\n\n\n\n\nVariable\nStd. Dev. (%)\nSD rel. to GDP\nAutocorrelation\nCorrelation with GDP\n\n\n\n\nOutput\n1.323\n1.000\n0.700\n1.000\n\n\nConsumption\n0.413\n0.312\n0.790\n0.897\n\n\nInvestment\n4.148\n3.137\n0.690\n0.991\n\n\nLabor\n0.645\n0.488\n0.688\n0.982\n\n\nTFP\n0.907\n0.686\n0.694\n0.998\n\n\n\n\n\n\nここで 表 1.1 と 表 1.3 の結果を比較すると, RBCモデルは実際のデータの2次モーメントをよく再現していることが分かります. 特に,\n\n消費と労働の標準偏差はGDPより小さい\n投資の標準偏差はGDPより数倍大きい\n\nところは実際のデータをよく再現しています. ただし, GDP \\(y\\) との相関は, 実際のデータよりも大きくなっています. これは, RBCモデルが TFPショックに対して非常に敏感であるためです.\nRBCモデルはとてもシンプルなモデルですが, 実際のデータの景気循環をよく再現することが分かります. そのため, RBCモデルを土台として, モデルを拡張することで, より現実的なモデルを構築することができます. 代表的な研究としては, 以下のように発展していきます.\n\n個人の異質性: Aiyagari (1994)\n金融の役割: New Keynesian モデル\n失業の役割: Merz (1995); Andolfatto (1996)\n\n\n\n\n\n\n\nAiyagari, S. Rao. 1994. “Uninsured Idiosyncratic Risk and Aggregate Saving.” The Quarterly Journal of Economics 109 (3): 659–84. https://doi.org/10.2307/2118417.\n\n\nAndolfatto, David. 1996. “Business Cycles and Labor-Market Search.” The American Economic Review 86 (1): 112–32. https://www.jstor.org/stable/2118258.\n\n\nAzzimonti, Marina, Per Krusell, Alisdair McKay, and Toshihiko Mukoyama. 2025. Macroeconomics.\n\n\nBaxter, Marianne, and Robert G. King. 1999. “Measuring Business Cycles: Approximate Band-Pass Filters for Economic Time Series.” The Review of Economics and Statistics 81 (4): 575–93. https://www.jstor.org/stable/2646708.\n\n\nBoppart, Timo, and Per Krusell. 2020. “Labor Supply in the Past, Present, and Future: A Balanced-Growth Perspective.” Journal of Political Economy 128 (1): 118–57. https://doi.org/10.1086/704071.\n\n\nCooley, Thomas F., and Edward C. Prescott. 1995. “Economic Growth and Business Cycles.” In Frontiers of Business Cycle Research, edited by Thomas F. Cooley, 1–38. Princeton University Press. https://doi.org/10.2307/j.ctv14163jx.7.\n\n\nKarabarbounis, Loukas, and Brent Neiman. 2014. “The Global Decline of the Labor Share.” The Quarterly Journal of Economics 129 (1): 61–103. https://doi.org/10.1093/qje/qjt032.\n\n\nKing, Robert G., Charles I. Plosser, and Sergio T. Rebelo. 1988. “Production, Growth and Business Cycles: I. The Basic Neoclassical Model.” Journal of Monetary Economics 21 (2): 195–232. https://doi.org/10.1016/0304-3932(88)90030-X.\n\n\nKydland, Finn E., and Edward C. Prescott. 1982. “Time to Build and Aggregate Fluctuations.” Econometrica 50 (6): 1345–70. https://doi.org/10.2307/1913386.\n\n\nLucas, Robert E. 1977. “Understanding Business Cycles.” Carnegie-Rochester Conference Series on Public Policy 5 (January): 7–29. https://doi.org/10.1016/0167-2231(77)90002-1.\n\n\nMerz, Monika. 1995. “Search in the Labor Market and the Real Business Cycle.” Journal of Monetary Economics 36 (2): 269–300. https://doi.org/10.1016/0304-3932(95)01216-8.\n\n\nMüller, Karsten, Chenzi Xu, Mohamed Lehbib, and Ziliang Chen. 2025. “The Global Macro Database: A New International Macroeconomic Dataset.”\n\n\nPrescott, Edward C. 1986. “Theory Ahead of Business Cycle Measurement.” Quarterly Review 10 (4). https://doi.org/10.21034/qr.1042.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>RBC Model</span>"
    ]
  },
  {
    "objectID": "01-rbc.html#footnotes",
    "href": "01-rbc.html#footnotes",
    "title": "1  Real Business Cycle Model",
    "section": "",
    "text": "これの詳細はかなり複雑そうなので省略します.↩︎\nPrescott の主張する消費と余暇の代替弾力性がおおよそ1であるという点も満たしている.↩︎\n ここでは簡易的にGDPに対する個人消費の割合を示していますが, 政府支出も民間に還元されていると考えられるため, 政府消費も含める必要があります. また, Cooley and Prescott (1995) では民間の耐久財消費を投資として扱うなど, モデル上の定義に合わせるために, 細かい調整が行われています.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>RBC Model</span>"
    ]
  },
  {
    "objectID": "02-nk.html",
    "href": "02-nk.html",
    "title": "2  New Keynesian Model",
    "section": "",
    "text": "2.1 New Keynesian Model とは\nNew Keynesian Model とは, RBCモデルに名目の硬直性 (nominal rigidity) を加えたモデルです. 名目賃金や名目価格が調整されるまでの時間がかかることを考慮し, このような価格や賃金を sticky price や sticky wage と呼びます. これにより, 短期的な価格の硬直性が生じ, 経済の変動に対する反応が遅れることになります. その結果, 名目変数 (貨幣供給や金利) が実体経済に影響を与えることが可能になります.\n\\[\n\\text{New Keynesian Model} = \\text{RBC Model} + \\text{Nominal Rigidity}.\n\\]\nDynamic Stochastic General Equilibrium (DSGE) モデルという呼称もありますが, これはRBCモデルやNew Keynesianモデルを含む, より一般的な呼称です. この授業ではRBCモデルと区別するためにNew Keynesianモデルと呼ぶことにします.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>New Keynesian</span>"
    ]
  },
  {
    "objectID": "02-nk.html#nominal-rigidity",
    "href": "02-nk.html#nominal-rigidity",
    "title": "2  New Keynesian Model",
    "section": "2.2 Nominal Rigidity",
    "text": "2.2 Nominal Rigidity\n\n2.2.1 Nominal vs. Real\nここで, 価格, 名目値と実質値という概念を導入します.\n\n\\(P_t\\): 名目価格 (nominal price). または物価水準 (price level)\n\\(i_t\\): 名目金利 (nominal interest rate)\n\nこの時, インフレ率 (inflation rate) \\(\\pi_t\\) は以下のように定義されます.\n\\[\n\\pi_t = \\frac{P_t - P_{t-1}}{P_{t-1}}.\n\\]\n今までのRBCモデルでは, 金利は実質金利 (real interest rate) \\(r_t\\) として扱ってきました. ここでいう実質金利とは, 名目金利からインフレ率を差し引いたものであり, 以下のように定義されます.\n\\[\n1 + r_t := \\frac{1 + i_t}{1 + \\pi_{t+1}}.\n\\]\nまた, \\(r_t \\pi_{t+1}\\) は無視できるほど十分小さいので, 近似的に以下のように表せます.\n\\[\nr_t \\approx i_t - \\pi_{t+1}.\n\\]\nこれをフィッシャー方程式 (Fisher Equation) と呼びます.\n\n\n2.2.2 Monetary Neutrality in RBC Model\nRBCモデルに価格がなぜ登場しなかったかというと, RBCモデルでは価格が完全に柔軟 (flexible) であると仮定しており, 価格が経済に影響を与えない 貨幣中立性 (monetary neutrality) が成立しているからです.\nここで, 従来のRBCモデルに価格 \\(P_t\\) を導入してみます. 単純化のために, 生産関数を \\(y_t = w_t n_t\\) とし, 名目貯蓄を \\(A_t\\) とします. すると, 家計の予算制約は以下のようになります.\n\\[\nP_t c_t + A_{t} = P_t w_t n_t + (1 + i_t) A_{t-1}.\n\\]\nこれを \\(P_t\\) で割ると, \\(a_t = \\frac{A_t}{P_t}\\) とすると,\n\\[\nc_t + a_{t} = w_t n_t + \\underbrace{\\frac{1 + i_t}{1 + \\pi_t}}_{= 1 + r_t} a_{t-1}.\n\\]\n企業の利潤は以下であり, \\(P_t\\) で割っても実質値 \\(y_t, w_t, n_t\\) に影響しません. \\[\n\\Pi_t = P_t y_t - P_t w_t n_t.\n\\]\n次節以降では, 企業の価格改訂コストを導入することで, 価格が実質値に影響を与えるようにします.\n\n\n2.2.3 Origin of Nominal Rigidity\nモデル上では抽象的な価格の硬直性を導入しますが, 具体的には以下のような理由で価格や賃金が硬直的になると考えられています.\n\nメニューコスト (menu cost): 価格を変更する際に, 印刷や広告などのコストがかかるため, 企業は頻繁に価格を変更しない\n合理的無関心 (rational inattention): 情報を収集し処理することにはコストがかかるため, 企業は合理的に情報を無視し, 価格を頻繁に変更しない\n\n\n\n\n\n\n\n図 2.1: Chart 2 from Goldberg and Hellerstein (2007)\n\n\n\n実証的にも価格の硬直性は観測されており, 図 2.1 はビールの価格があまり頻繁に変更されないことを示しています.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>New Keynesian</span>"
    ]
  },
  {
    "objectID": "02-nk.html#model",
    "href": "02-nk.html#model",
    "title": "2  New Keynesian Model",
    "section": "2.3 Model",
    "text": "2.3 Model\n\n2.3.1 IS-MP-PC モデル\nNew Keynesian モデルの基本的な枠組みはRBCモデルに価格硬直性を加えたものです. モデルの設定は次節以降で詳しく説明しますが, 最終的には以下の3つの式に集約されます.\n\\[\n\\begin{aligned}\n\\widetilde{Y}_t &= \\mathbb{E}_t\\left[\\widetilde{Y}_{t+1}\\right] - \\frac{1}{\\sigma}\\left(i_t -\\mathbb{E}_t\\left[\\pi_{t+1}\\right] - r_t^n\\right) & \\text{(NK IS Curve)} \\\\\n\\pi_{t} &= \\beta \\mathbb{E}_t\\left[\\pi_{t+1}\\right] + \\kappa \\widetilde{Y}_t & \\text{(NK Phillips Curve)} \\\\\ni_t &= r_t + \\phi_{\\pi}\\pi_t + \\phi_y \\widetilde{Y}_t & \\text{(MP Rule)}\\\\\n\\end{aligned}\n\\]\n\n\\(\\widetilde{Y}_t\\): 産出ギャップ (output gap)\n\\(i_t\\): 名目金利\n\\(\\pi_t\\): インフレ率\n\\(r_t^n\\): 自然利子率 (natural interest rate)\n\nなおこの方程式は線形であるため, 全てを100倍にしたパーセント表記にしても同じです. 導出の過程では扱いやすい実際の値 (\\(\\pi_t\\) = 0.01 ならば1%のインフレ率) で扱いますが, IS-MP-PCの形になった後は, パーセントとして扱って (\\(\\pi_t = 1\\) ならば1%のインフレ率) も問題ありません. 実務上はパーセントとして扱っているものが多いです.\nFlexible Price Equilibrium\n金融政策を考える際にベンチマークとして, 価格が完全に柔軟である場合の均衡状態を考えます. これを自然 (natural) な状態と呼びび, \\(x_t^n\\) のように表します. 産出ギャップ \\(Y_t^n\\) は自然水準との対数差で定義されます.\n\\[\n\\widetilde{Y}_t := \\log Y_t - \\log Y_t^n.\n\\]\n\n\n2.3.2 設定\n公共セクター\n\n中央銀行は名目利子率を制御する金融ルール (Monetary Policy Rule) を持つ\n政府は (この授業のモデルでは) 考慮しない\n\n民間セクター\n\n民間セクターは, 家計, 中間財企業, 最終財企業から構成される\n家計は最終財を消費し, 中間財企業に労働を供給する\n最終財企業は中間財企業から中間財を調達し, 最終財を生産する (完全競争)\n中間財企業は差別化された中間財を生産し, 最終財企業に販売する (独占的競争)\n\nRotemberg (1982) vs. Calvo (1983)\n価格の硬直性を考慮する際に, 価格の調整がどのように行われるかについては2つのアプローチがあります.\n\nRotemberg (1982): 価格の調整はコストがかかるとし, 価格を調整する企業はそのコストを考慮して価格を設定する\nCalvo (1983): 価格の調整は確率的に行われるとし, 各企業が価格を調整する確率を一定とする\n\nIS-MP-PC のような線形化されたモデルでは, どちらのアプローチを用いても同じ結果になりますが, 非線形のまま数値計算を行う場合は結果が少し異なります. 二つのモデルの違いについては Ascari and Rossi (2012) などを参照してください. この授業では, 線形化したモデルを扱うことと, 導出が平易なことから Rotemberg (1982) のアプローチを採用します.\n\n\n2.3.3 家計\n代表的な家計は以下の期待割引価値を最大化すると考えます.\n\\[\nU_0 = \\mathbb{E}_0 \\sum_{t=0}^{\\infty} \\beta^t \\left(\\frac{C_t^{1-\\sigma}}{1-\\sigma} - \\frac{N_t^{1+\\phi}}{1+\\phi}\\right)\n\\]\n\n\\(C_t\\): (最終財) 消費\n\\(N_t\\): 労働供給\n\n家計の各期の予算制約は以下のようになります.\n\\[\nP_t C_t + \\frac{1}{1 + i_{t}} B_{t} = W_t N_t + \\Pi_t + B_{t-1}.\n\\]\n\n\\(P_t\\): 最終財価格\n\\(B_{t}\\): 名目債券 (nominal bond) の一期保有量 (one-period bond holdings)\n\\(i_t\\): 名目金利 (nominal interest rate)\n\\(W_t\\): 名目賃金 (nominal wage)\n\\(\\Pi_t\\): 企業の名目利益 (nominal profits)\n\nベルマン方程式\n\\[\n\\begin{aligned}\nV(B_{t-1}) &= \\max_{C_t, N_t, B_t} \\frac{C_t^{1-\\sigma}}{1-\\sigma} - \\frac{N_t^{1+\\phi}}{1+\\phi} + \\beta \\mathbb{E}_t\\left[V(B_{t})\\right] \\\\\n&=\\max_{C_t, N_t} \\frac{C_t^{1-\\sigma}}{1-\\sigma} - \\frac{N_t^{1+\\phi}}{1+\\phi} + \\beta \\mathbb{E}_t\\left[V\\left((1+i_t)(W_t N_t + \\Pi_t + B_{t-1} - P_t C_t)\\right)\\right]\n\\end{aligned}\n\\]\n最適条件\n\\[\n\\begin{aligned}\nC_t^{-\\sigma} &= \\beta (1+i_t) P_t \\mathbb{E}_t\\left[V'(B_{t})\\right] & \\text{(FOC of $C_t$)} \\\\\nN_t^{\\phi} &= \\beta (1+i_t) W_t \\mathbb{E}_t\\left[V'(B_{t})\\right] & \\text{(FOC of $N_t$)}\\\\\nV'(B_{t-1}) &= \\beta (1+i_t)\\mathbb{E}_t\\left[V'(B_{t})\\right] & \\text{(EC of $B_{t-1}$)}\n\\end{aligned}\n\\]\nここから, \\(V'(B_{t-1}) = \\frac{C_t^{-\\sigma}}{P_t}\\) が導けます. これを用いて,\n\\[\n\\begin{aligned}\nC_t^{-\\sigma} &= \\beta \\mathbb{E}_t\\left[\\frac{P_t}{P_{t+1}} (1+i_t)C_{t+1}^{-\\sigma}\\right] & \\text{(Euler equation)} \\\\\nC_t^{-\\sigma}\\frac{W_t}{P_t} &= N_t^{\\phi} & \\text{(Intratemporal labor supply)}\n\\end{aligned}\n\\tag{2.1}\\]\nこれは実質値を考えると, RBCモデルと同じ含意が得られることが分かります.\n\\[\n\\begin{aligned}\nC_t^{-\\sigma} &= \\beta \\mathbb{E}_t\\left[(1 + r_t) C_{t+1}^{-\\sigma}\\right] \\\\\nC_t^{-\\sigma} w_t &= N_t^{\\phi}\n\\end{aligned}\n\\]\n\n\n2.3.4 企業\n生産\n消費者は最終財 (final good) を消費します. 最終財は代表的企業が中間財 \\(j \\in [0, 1]\\) を以下のCES生産関数で生産します.\n\\[\nY_t = \\left(\\int_{0}^{1} Y_{j, t}^{\\frac{\\varepsilon - 1}{\\varepsilon}} \\,dj\\right)^{\\frac{\\varepsilon}{\\varepsilon - 1}}.\n\\]\n\n\\(Y_{j, t}\\): 中間財 \\(j\\) の生産量\n\\(\\varepsilon\\): 代替弾力性 (elasticity of substitution)\n\n中間財は以下の線形生産関数で生産されます.\n\\[\nY_{j, t} = A_t N_{j, t}\n\\]\n価格\n最終財の価格 \\(P_t\\) は中間財の価格 \\(P_{j, t}\\) を用いて以下のように表されます.\n\\[\nP_t = \\left(\\int_{0}^{1} P_{j, t}^{1-\\varepsilon} \\, dj \\right)^{\\frac{1}{1-\\varepsilon}}.\n\\]\n証明は 命題 B.1 を参照してください.\n中間財の価格 \\(P_{j, t}\\) は, 企業 \\(j\\) が独占的に設定します. このコストは, 最終財で計測され, 以下の Rotemberg (1982) 型の価格改訂コストがかかります.\n\\[\n\\frac{\\varphi}{2}\\left(\\frac{P_{j, t}}{P_{j, t-1}} - 1\\right)^2 Y_t.\n\\]\n中間財企業は, 賃金 \\(W_t\\) を (プライステイカーとして) 支払います. そのため, 中間財企業 \\(j\\) の限界費用 (marginal cost) は以下のように表されます.\n\\[\nMC_{j, t} = \\frac{W_t}{A_t}\n\\]\nこれは, 企業ごとに同一のため \\(MC_{t}\\) と表記します.\n最適化問題\n中間財企業 \\(j\\) は以下の価値関数を最大化します.\n\\[\n\\max_{\\{P_{j, t}\\}_{t=0}^{\\infty}} \\mathbb{E}_{0} \\sum_{t=0}^{\\infty} D_{0, t} \\left[\n    \\left(\\frac{P_{j, t}}{P_t} - MC_{t}^{r}\\right)Y_{j, t} -\n    \\frac{\\varphi}{2}\\left(\\frac{P_{j, t}}{P_{j, t-1}} - 1\\right)^2 Y_t\n\\right]\n\\]\nここで, \\(D_{0, t} := \\beta^t \\frac{U_{c}(t)}{U_{c}(0)}\\) は確率的割引因子（stochastic discount factor）です.\n\n企業の所有者は代表的家計であり、企業価値は家計の効用で測定される\n\\(U_c(t) = C_t^{-\\sigma}\\) は \\(t\\) 期の消費の限界効用\n\\(U_c(0)\\) で割ることで, 0期時点の効用を基準に相対的な価値を表す\n最終財の価格を基準に考えるため, 実質限界費用 \\(MC_{t}^{r} = \\frac{W_t}{A_t P_t}\\) を用います.\n\nここから以下のベルマン方程式を得ます.\n\\[\nV(P_{j, t-1}) = \\max_{P_{j, t}} \\left(\\frac{P_{j, t}}{P_t} - MC_{t}^{r}\\right)Y_{j, t} - \\frac{\\varphi}{2}\\left(\\frac{P_{j, t}}{P_{j, t-1}} - 1\\right)^2 Y_{t} + \\mathbb{E}_{t}[D_{t+1}V(P_{j, t})].\n\\]\nここで, \\(D_{t, t+1}\\) を省略して, \\(D_{t+1} := \\beta \\frac{U_{c}(t+1)}{U_{c}(t)}\\) としました.\n最適価格\n中間財需要 \\(Y_{j, t} = \\left(\\frac{P_{j, t}}{P_t}\\right)^{-\\varepsilon}Y_t\\) を代入すると, ベルマン方程式は以下のようになります.\n\\[\nV(P_{j, t-1}) = \\max_{P_{j, t}} \\left(\\frac{P_{j, t}}{P_t} - MC_{t}^{r}\\right)\\left(\\frac{P_{j, t}}{P_t}\\right)^{-\\varepsilon}Y_t - \\frac{\\varphi}{2}\\left(\\frac{P_{j, t}}{P_{j, t-1}} - 1\\right)^2 Y_t + \\mathbb{E}_{t}[D_{t+1}V(P_{j, t})].\n\\]\n最適化条件は以下のようになります.\n\\[\n\\left((1-\\varepsilon)\\left(\\frac{P_{j, t}}{P_t}\\right)^{-\\varepsilon} + \\varepsilon MC_{t}^{r} \\left(\\frac{P_{j, t}}{P_t}\\right)^{-\\varepsilon-1}\\right)\\frac{Y_t}{P_t} -\n\\varphi \\left(\\frac{P_{j, t}}{P_{j, t-1}} - 1\\right)\\frac{Y_t}{P_{j, t-1}} + \\mathbb{E}_{t}[D_{t+1}V'(P_{j, t})] = 0\n\\]\n\\[\nV'(P_{j, t-1}) = \\varphi \\left(\\frac{P_{j,t}}{P_{j, t-1}} - 1\\right)\\frac{P_{j, t}}{P_{j, t-1}^2}Y_t\n\\]\n対称均衡を仮定すると, 全ての企業は同じ価格を設定するため, \\(P_{j, t} = P_t\\) とおけます. これにより, 次の式を得ます.\n\\[\n(1-MC_{t}^r)\\varepsilon = 1 - \\varphi\\pi_{t}(1+\\pi_{t}) + \\varphi \\beta\\mathbb{E}_t\\left[\n  \\left(\\frac{C_{t+1}}{C_{t}}\\right)^{-\\sigma}\\pi_{t+1}(1+\\pi_{t+1})\\frac{Y_{t+1}}{Y_t}\n\\right].\n\\tag{2.2}\\]\nここで \\(1 + \\pi_{t} := \\frac{P_{t}}{P_{t-1}}\\) とおきました.\n\n\n2.3.5 均衡\nMarket clearing\n\\[\n\\begin{aligned}\nN_t &= \\int N_{j, t} \\,dj & \\text{Labor Market Clearing} \\\\\nY_t &= C_t & \\text{Goods Market Clearing}\n\\end{aligned}\n\\]\nRotemberg (1982) 型のモデルでは, 価格改訂のコストを\n\n意思決定に影響を及ぼすが, 実体経済に直接的な影響を与えない\n価格改訂には, 最終財の生産量に依存するコストがかかる\n\nという2つの考え方があります. \\(Y_t = C_t\\) という条件はこの1つ目の考え方に基づいています. 2つ目の考え方は Exercise で扱います.\n\n\n2.3.6 Flexible Price Equilibrium\n価格が柔軟である場合, 価格の改定にはコストがかかりません. すなわち, ベルマン方程式は以下のようになります.\n\\[\nV(P_{j, t-1}) = \\max_{P_{j, t}} \\left(\\frac{P_{j, t}}{P_t} - MC_{t}^{r}\\right)Y_{j, t} + \\mathbb{E}_{t}[D_{t+1}V(P_{j, t})].\n\\]\nこの時, \\(P_{j, t-1}\\) に依存しないため, state variables にもなりません. したがって, さらに書き換えると,\n\\[\nV = \\max_{P_{j, t}} \\left(\\frac{P_{j, t}}{P_t} - MC_{t}^{r}\\right)Y_{j, t} + \\mathbb{E}_{t}[D_{t+1}V].\n\\]\n\\(Y_{j, t} = \\left(\\frac{P_{j, t}}{P_t}\\right)^{-\\varepsilon}Y_t\\) を代入し, 最適化条件を求めると,\n\\[\n(1-\\varepsilon)\\left(\\frac{P_{j,t}}{P_t}\\right)^{-\\varepsilon} = MC_{t}^{r}(-\\varepsilon)\\left(\\frac{P_{j,t}}{P_t}\\right)^{-\\varepsilon-1}.\n\\]\n対称均衡を仮定すると, \\(P_{j, t} = P_t\\) より, 以下の式を得ます.\n\\[\nMC_{t}^{r} = \\frac{\\varepsilon - 1}{\\varepsilon} =: \\frac{1}{\\mu}.\n\\]\nここで, \\(\\mu := \\frac{\\varepsilon}{\\varepsilon - 1}\\) はマークアップ率 (markup rate) と呼ばれます. マークアップ率は, 企業が価格を設定する際に, 限界費用に対してどれだけ上乗せするかを示す指標です. すなわち,\n\\[\n\\frac{P_t}{MC_t} = \\frac{1}{MC_t^r} =: \\mu.\n\\]\nFlexible price の均衡における値を \\(X^n\\) で表すと,\n\\[\n\\begin{aligned}\nY_t^n &= A_t N_t^n \\\\\nMC_{t}^{r, n} &= \\frac{W_t^n}{A_t P_t^n} = \\frac{1}{\\mu} \\\\\n\\frac{W_t^n}{P_t^n} &= {C_t^n}^{\\sigma} {N_t^{n}}^{\\phi} \\\\\nY_t^n &= C_t^n\n\\end{aligned}\n\\]\nこれらを整理すると, 以下の式を得ます.\n\\[\nY_t^n = \\mu^{-\\frac{1}{\\sigma + \\phi}} A_t^{\\frac{1+\\phi}{\\sigma + \\phi}}.\n\\tag{2.3}\\]\nなお, 対数線形化すると自明に\n\\[\n\\hat{Y}_t^n = \\frac{1+\\phi}{\\sigma + \\phi} \\hat{A}_t.\n\\tag{2.4}\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>New Keynesian</span>"
    ]
  },
  {
    "objectID": "02-nk.html#is-mp-pc-の導出",
    "href": "02-nk.html#is-mp-pc-の導出",
    "title": "2  New Keynesian Model",
    "section": "2.4 IS-MP-PC の導出",
    "text": "2.4 IS-MP-PC の導出\nここでは, 定常状態におけるゼロインフレ率 \\(\\pi = 0\\) を仮定します. ほとんどの論文ではこれを仮定しますが, 仮定しない場合は ISとPCの形は複雑になります. 詳細は Ascari and Rossi (2012) を参照してください.\nまた, ゼロインフレでは価格改訂が起こらないので, 定常状態では価格改訂コストは存在しません. したがって, 定常状態では柔軟価格均衡と同じ値を取ります \\((Y = Y^n)\\).\n\n2.4.1 New Keynesian IS Curve\n式 2.1 のオイラー方程式から導出します.\n\\[\nC_t^{-\\sigma} = \\beta \\mathbb{E}_t\\left[\\frac{1+i_t}{1+\\pi_{t+1}}C_{t+1}^{-\\sigma}\\right]\n\\]\nこれを対数線形化すると (命題 B.2), 以下の式を得ます.\n\\[\n\\hat{C}_t = \\mathbb{E}_t\\left[\\hat{C}_{t+1}\\right] - \\frac{1}{\\sigma}\\left(i_t + \\log \\beta - \\mathbb{E}_t\\left[\\pi_{t+1}\\right] \\right)\n\\tag{2.5}\\]\n補題 B.1 より, 産出ギャップは \\(\\widetilde{Y}_t = \\hat{Y}_t - \\hat{Y}_t^n\\) であり, 式 2.4 を用いると,\n\\[\n\\hat{Y}_t = \\widetilde{Y}_t + \\frac{1+\\phi}{\\sigma + \\phi} \\hat{A}_t.\n\\]\nGood Market Clearing (\\(C_t = Y_t\\)) より, \\(\\hat{C}_t = \\hat{Y}_t\\) なので,\n\\[\n\\widetilde{Y}_t = \\mathbb{E}_t\\left[\\widetilde{Y}_{t+1}\\right] - \\frac{1}{\\sigma}\\left(i_t - \\mathbb{E}_t\\left[\\pi_{t+1}\\right] - r_t^n\\right)\n\\tag{2.6}\\]\nなぜなら, 自然利子率は \\(r_t^n := i_t^n - \\mathbb{E}_t\\left[\\pi_{t+1}^n\\right]\\) で定義され, 式 2.5 と 式 2.4 を用いると,\n\\[\nr_t^n = -\\log \\beta + \\frac{\\sigma(1+\\phi)}{\\sigma + \\phi}\\left(\\mathbb{E}_t\\left[\\hat{A}_{t+1}\\right] - \\hat{A}_t\\right).\n\\]\nと表されるからです. 定常状態では明らかに \\(r^n = -\\log \\beta\\) となります.\nNKIS 式 2.6 の解釈としては, 産出ギャップが将来の産出ギャップ予想 \\(\\mathbb{E}_t\\left[\\widetilde{Y}_{t+1}\\right]\\) と, 実質金利のギャップ \\(i_t - \\mathbb{E}_t\\left[\\pi_{t+1}\\right] - r_t^n\\) によって決定されることを示しています.\n\n将来の産出ギャップ予想: 家計は消費を平滑化しようとするため, 将来の産出ギャップが高いと予想される場合, 現在の産出ギャップも高くなる\n実質金利のギャップ: 実質金利が高い場合, 貯蓄を増やし現在の消費を減らす. その結果, 産出ギャップが減少する\n\n\n\n2.4.2 New Keynesian Phillips Curve\n式 2.2 の式を用いて, 価格の硬直性を考慮したフィリップス曲線を導出します.\n\\[\n(1-MC_{t}^r)\\varepsilon = 1 - \\varphi\\pi_{t}(1+\\pi_{t}) + \\varphi \\beta\\mathbb{E}_t\\left[\n  \\left(\\frac{C_{t+1}}{C_{t}}\\right)^{-\\sigma}\\pi_{t+1}(1+\\pi_{t+1})\\frac{Y_{t+1}}{Y_t}\n\\right].\n\\]\nこれを対数線形化すると (命題 B.3), 以下の式を得ます.\n\\[\n\\begin{aligned}\n\\pi_t&= \\beta \\mathbb{E}_t\\left[\\pi_{t+1}\\right] + (1-\\beta)\\pi +\n\\frac{\\varepsilon-1 + (1-\\beta)\\varphi\\pi(1+\\pi)}{\\varphi(1+\\pi)(1+2\\pi)}\\widehat{MC^r}_{t} \\\\\n&+\\frac{\\beta\\pi}{\\varphi(1+2\\pi)}\\mathbb{E}_t\\left[\\Delta \\hat{Y}_{t+1} - \\sigma \\Delta\\hat{C}_{t+1}\\right]\n\\end{aligned}\n\\]\n\\(\\pi = 0\\) より,\n\\[\n\\pi_{t} = \\beta \\mathbb{E}_t\\left[\\pi_{t+1}\\right] + \\frac{\\varepsilon-1}{\\varphi} \\widehat{MC^r}_{t}.\n\\]\n補題 B.2 を用いて,\n\\[\n\\pi_{t} = \\beta \\mathbb{E}_t\\left[\\pi_{t+1}\\right] + \\frac{\\varepsilon-1}{\\varphi} (\\sigma+\\phi)\\widetilde{Y}_t.\n\\]\n\\(\\kappa = \\frac{(\\varepsilon-1)(\\sigma+\\phi)}{\\varphi}\\) とすると,\n\\[\n\\pi_t = \\beta \\mathbb{E}_t\\left[\\pi_{t+1}\\right] + \\kappa \\widetilde{Y}_t.\n\\tag{2.7}\\]\n解釈としては, 現在のインフレ率が将来のインフレ予想 \\(\\mathbb{E}_t\\left[\\pi_{t+1}\\right]\\) と, 現在の景気状況 \\(\\widetilde{Y}_t\\) によって決定されることを示しています.\n\nインフレ予想: 急激な価格改訂はコストがかかるため, インフレが予想される場合は, 企業は事前に価格を引き上げる\n産出ギャップ: 需要が高まると, 労働需要が高まり, 賃金が上昇する. 企業はコスト上昇を価格に転嫁し, インフレ率が上昇する\n\n\n\n2.4.3 Monetary Policy Rule (Taylor Rule)\nTaylor (1993) は1987-1992年の Federal Reserve の政策を分析し, 以下のようなルールを提案しました.\n\\[\ni_t = r^n + \\phi_{\\pi}(\\pi_t - \\pi^*) + \\phi_y \\widetilde{Y}_t\n\\tag{2.8}\\]\nTaylor (1993) では \\(\\phi_{\\pi} = 1.5\\), \\(\\phi_{y} = 0.5\\) としています. 解釈としては,\n\n\\(\\phi_{\\pi} &gt; 1\\) の場合, インフレ率が目標を上回るとき, 金利を上げることでインフレを抑制しようとする\n\\(\\phi_y &gt; 0\\) の場合, GDPギャップが正のとき, 金利を上げることで景気を抑制しようとする\n\nFRB of Atlanta の Taylor Rule Utility では, いくつかのモデルやパラメータを指定して, Taylor Rule と実際の金利 (Fed Funds Rate) の比較を行うことができます 図 2.2. “Alternative 3” として表示されているルールが Taylor (1993) のルールに近いものです. Taylor (1993) の観測した1987-1992年の期間をよく説明しているだけでなく, その後の期間もある程度説明できていることがわかります.\n\n\n\n\n\n\n図 2.2: Taylor Rules from Fedral Reserve Bank of Atlanta.\n\n\n\nなお, 実際の金利は金利ゼロ制約 (Zero Lower Bound, ZLB) によって制約されるため, 超低金利の場合では Taylor Rule が適用できないことに注意してください. ZLBを考慮した数値計算モデルとしては, Adam and Billi (2007) などがあり, 北尾, 砂川, and 山田 (2024) の7章で詳しく説明されています.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>New Keynesian</span>"
    ]
  },
  {
    "objectID": "02-nk.html#simulation",
    "href": "02-nk.html#simulation",
    "title": "2  New Keynesian Model",
    "section": "2.5 Simulation",
    "text": "2.5 Simulation\nここからは, Impulse Response Function (IRF) をシミュレーションしていきます. また, 単純化のため, 中央銀行の目標インフレ率は \\(\\pi^* = 0\\) とします. これは, 定常状態のインフレ率を0と仮定していることと整合的になるからです.1\n\n2.5.1 Calibration\nParameters\nモデルの一期間は四半期とし, 以下のパラメータを設定します. Ascari and Rossi (2012) のパラメータを用います.\n\n\n\n表 2.1: New Keynesian Model Parameters\n\n\n\n\n\n\n\n\n\nParameter\nDescription\n\n\n\n\n\\(\\beta=0.99\\)\n\\(\\beta = 0.96\\) の四半期換算\n\n\n\\(\\sigma=1\\)\nLog Utility\n\n\n\\(\\phi=1\\)\nUnitary Frisch elasticity\n\n\n\\(\\varepsilon=10.0\\)\nLiterature\n\n\n\\(\\varphi=104.9\\)\n脚注参照2\n\n\n\\(\\phi_{\\pi}=1.5\\)\nTaylor (1993)\n\n\n\\(\\phi_{y}=0.125\\)\nTaylor (1993) の四半期換算\n\n\n\n\n\n\nMonetary Policy Shocks\nIRFをシミュレーションするために, 式 2.8 に以下のショックを与えます.\n\\[\n\\begin{aligned}\ni_t &= r^n + \\phi_{\\pi}\\pi_t + \\phi_y \\widetilde{Y}_t + \\eta_t \\\\\n\\eta_t &= \\rho_{\\eta} \\eta_{t-1} + \\sigma_{\\eta} \\epsilon_t.\n\\end{aligned}\n\\]\nIRFのシミュレーションでは, \\(t=0\\) 時点で \\(\\epsilon_t = 1\\) とし, そのあとは \\(\\epsilon_t = 0\\) とします. Galí (2015) のChapter 3に従い, \\(\\rho_{\\eta} = 0.5\\), \\(\\sigma_{\\eta} = 0.25\\) とします.\n\n\n2.5.2 IRF from Scratch\n補題 B.3 より,\n\\[\n\\begin{pmatrix}\n\\widetilde{Y}_t \\\\\n\\pi_t\n\\end{pmatrix}\n=\\omega\\underbrace{\\begin{pmatrix}\n\\sigma & 1-\\beta\\phi_{\\pi} \\\\\n\\sigma\\kappa & \\kappa+\\beta(\\sigma+\\phi_y)\n\\end{pmatrix}}_{\\Lambda}\n\\begin{pmatrix}\n\\mathbb{E}_t\\left[\\widetilde{Y}_{t+1}\\right] \\\\\n\\mathbb{E}_t\\left[\\pi_{t+1}\\right]\n\\end{pmatrix}\n+\\omega\\underbrace{\\begin{pmatrix}\n1\\\\\n\\kappa\n\\end{pmatrix}}_{\\mathbf{b}}\n\\left(\\hat{r}_t^n - \\eta_t\\right).\n\\]\nここで, \\(\\omega = (\\sigma+\\phi_y+\\phi_{\\pi}\\kappa)^{-1}\\), \\(\\hat{r}_t^n = r_t^n - r^n\\) です. Monetary policy shocks は自然利子率に影響を与えないため, \\(\\hat{r}_t^n = 0\\) とします.\nこのように, 期待演算子を含む線形システムが得られました. これを前方期待 (foward-looking) を含む線形モデルと呼び, このようなモデルを解くには guess-and-verify が有効です.\nこのシステムの解が以下の形を満たすとします.\n\\[\n\\widetilde{Y}_t = \\psi_y \\eta_t, \\quad \\pi_t = \\psi_{\\pi} \\eta_t.\n\\]\nこれを代入して, \\((\\psi_y, \\psi_{\\pi})\\) に対して解くと,\n\\[\n\\begin{aligned}\n\\begin{pmatrix}\n\\psi_y\\\\\\psi_{\\pi}\n\\end{pmatrix}\\eta_t&=\\omega \\Lambda\\begin{pmatrix}\n\\psi_y\\\\\\psi_{\\pi}\n\\end{pmatrix}\\mathbb{E}_t\\left[\\eta_{t+1}\\right] - \\omega \\mathbf{b} \\eta_t\\\\\n&=\\omega \\Lambda\\begin{pmatrix}\n\\psi_y\\\\\\psi_{\\pi}\n\\end{pmatrix}\n\\rho_{\\eta}\\eta_t - \\omega \\mathbf{b} \\eta_t\\\\\n\\begin{pmatrix}\n\\psi_y\\\\\\psi_{\\pi}\n\\end{pmatrix}&=(I - \\omega\\rho_{\\eta}\\Lambda)^{-1} (-\\omega \\mathbf{b}).\n\\end{aligned}\n\\]\nこのようにして, \\(\\psi_y, \\psi_{\\pi}\\) を求めることができれば3, IRFを計算することができます.\n\n\nCode\nmodule My\n\n@kwdef struct NK{TF&lt;:AbstractFloat}\n    β::TF = 0.99\n    σ::TF = 1.0\n    ϕ::TF = 1.0\n    ε::TF = 10.0\n    θ::TF = 0.75\n    φ::TF = (ε - 1) * θ / ((1 - θ) * (1 - β * θ))\n    κ::TF = (ε - 1) * (σ + ϕ) / φ\n    ϕ_π::TF = 1.5\n    ϕ_y::TF = 0.125\n    rⁿ::TF = -log(β)\n    ρ_η::TF = 0.5\n    σ_η::TF = 0.25\nend\n\nfunction get_irf(m::NK; T=12, σ_ε=0.25)\n    (; β, σ, κ, rⁿ, ϕ_π, ϕ_y, ρ_η) = m\n\n    # Sequence of Shocks\n    ηs = zeros(T + 1)\n    ηs[1] = σ_ε\n    for t in 1:T\n        ηs[t+1] = ρ_η * ηs[t]\n    end\n\n    # IRF\n    ω = 1 / (σ + ϕ_y + ϕ_π * κ)\n    Λ = [σ (1-β*ϕ_π)\n        σ*κ κ+β*(σ+ϕ_y)]\n    𝐛 = [1, κ]\n\n    ψ_y, ψ_π = ([1 0; 0 1] - ω * ρ_η * Λ) \\ (-ω * 𝐛)\n    ỹs = ψ_y * ηs\n    πs = ψ_π * ηs\n    is = rⁿ .+ ϕ_π * πs .+ ϕ_y * ỹs .+ ηs\n\n    return ỹs, πs, is, ηs\nend\n\nend # module\n\n\n\n\nCode\nm = My.NK()\nT = 12\nỹs, πs, is, ηs = My.get_irf(m, T=T)\n\np1 = plot(0:T, ỹs, title=L\"Output Gap $\\widetilde{Y}_t$\", label=false)\np2 = plot(0:T, πs, title=L\"Inflation $\\pi_t$\", label=false)\np3 = plot(0:T, is, title=L\"Nominal Interest Rate $i_t$\", label=false)\np4 = plot(0:T, ηs, title=L\"Shock $\\eta_t$\", label=false)\n\np = plot(p1, p2, p3, p4, layout=(2, 2), xticks=0:2:T)\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 2.3: IRF of New Keynesian Model from Scratch\n\n\n\n\n解釈としては, 正の金利ショックが起きた時\n\n実質金利の増加により, 現在の消費が減少 (NKIS)\n\\(Y_t = C_t\\) かつ, \\(Y_t^n\\) は影響を受けないため, Output Gap \\(\\widetilde{Y}_t\\) が減少\nOutput Gapの減少により, インフレ率 \\(\\pi_t\\) が減少 (NKPC)\n\n\n\n2.5.3 IRF by MacroModelling.jl\n同じシミュレーションを, MacroModelling.jl パッケージを用いて行うこともできます. 線形化したモデルを用いてもいいですが, 非線形なモデルを直接定義することもできます.\n\n\nCode\n@model NK begin\n    C[0]^(-σ) = β * (1 + i[0]) / (1 + π[1]) * C[1]^(-σ)\n    N[0]^ϕ = C[0]^(-σ) * Wr[0]\n    (1 - MCr[0]) * ε = 1 - φ * π[0] * (1 + π[0]) +\n                       φ * β * (C[1] / C[0])^(-σ) * π[1] * (1 + π[1]) * Y[1] / Y[0]\n    i[0] = rⁿ + ϕ_π * π[0] + ϕ_y * ỹ[0] + η[0]\n    Y[0] = A * N[0]\n    Y[0] = C[0]\n    ỹ[0] = log(Y[0]) - log(Yⁿ)\n    MCr[0] = Wr[0] / A\n    η[0] = ρ_η * η[-1] + σ_ϵ * ϵ[x]\nend\n\n@parameters NK begin\n    σ = 1.0\n    ϕ = 1.0\n    ε = 10.0\n    θ = 0.75\n    φ = (ε - 1) * θ / ((1 - θ) * (1 - β * θ))\n    A = 1.0\n    β = 0.99\n    rⁿ = 1 / β - 1 # Cannot use -log(β). It seems a bug of MacroModelling.jl\n    Yⁿ = μ^(-1 / (σ + ϕ)) * A^((1 + ϕ) / (σ + ϕ))\n    μ = ε / (ε - 1)\n    ϕ_π = 1.5\n    ϕ_y = 0.125\n    ρ_η = 0.5\n    σ_ϵ = 0.25\nend\n\n\n\n\nCode\nT = 12\nirf = get_irf(NK, periods=T + 1, variables=[:i, :η, :π])\nỹs = collect(get_irf(NK, periods=T + 1, variables=[:ỹ], levels=true)[1, :])\n\np1 = plot(0:T, ỹs, title=L\"Output Gap $\\widetilde{Y}_t$\", label=false)\np2 = plot(0:T, irf[3, :], title=L\"Inflation $\\pi_t$\", label=false)\np3 = plot(0:T, irf[1, :], title=L\"Nominal Interest Rate $i_t$\", label=false)\np4 = plot(0:T, irf[2, :], title=L\"Shock $\\eta_t$\", label=false)\n\nplot(p1, p2, p3, p4, layout=(2, 2), xticks=0:2:T)\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 2.4: IRF of New Keynesian Model by MacroModelling.jl\n\n\n\n\n図 2.3 と全く同じ結果が得られます. 実は, MacroModelling.jl や Dynare といったパッケージは, 対数線形化とそのシミュレーションを自動で行うためのツールだったです.4\n\n\n\n\n\n\nAdam, Klaus, and Roberto M. Billi. 2007. “Discretionary Monetary Policy and the Zero Lower Bound on Nominal Interest Rates.” Journal of Monetary Economics 54 (3): 728–52. https://doi.org/10.1016/j.jmoneco.2005.11.003.\n\n\nAscari, Guido, and Lorenza Rossi. 2012. “Trend Inflation and Firms Price-Setting: Rotemberg Versus Calvo.” The Economic Journal 122 (563): 1115–41. https://doi.org/10.1111/j.1468-0297.2012.02517.x.\n\n\nBullard, James, and Kaushik Mitra. 2002. “Learning about Monetary Policy Rules.” Journal of Monetary Economics 49 (6): 1105–29. https://doi.org/10.1016/S0304-3932(02)00144-7.\n\n\nCalvo, Guillermo A. 1983. “Staggered Prices in a Utility-Maximizing Framework.” Journal of Monetary Economics 12 (3): 383–98. https://doi.org/10.1016/0304-3932(83)90060-0.\n\n\nGalí, Jordi. 2015. Monetary Policy, Inflation, and the Business Cycle: An Introduction to the New Keynesian Framework and Its Applications. Second edition. Princeton Oxford: Princeton University Press.\n\n\nGoldberg, Pinelopi, and Rebecca Hellerstein. 2007. “Sticky Prices: Why Firms Hesitate to Adjust the Price of Their Goods.” Current Issues in Economics and Finance 13 (10).\n\n\nRotemberg, Julio J. 1982. “Sticky Prices in the United States.” Journal of Political Economy 90 (6): 1187–1211. https://doi.org/10.1086/261117.\n\n\nTaylor, John B. 1993. “Discretion Versus Policy Rules in Practice.” Carnegie-Rochester Conference Series on Public Policy 39 (December): 195–214. https://doi.org/10.1016/0167-2231(93)90009-L.\n\n\n北尾早霧, 砂川武貴, and 山田知明. 2024. 定量的マクロ経済学と数値計算. 日本評論社.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>New Keynesian</span>"
    ]
  },
  {
    "objectID": "02-nk.html#footnotes",
    "href": "02-nk.html#footnotes",
    "title": "2  New Keynesian Model",
    "section": "",
    "text": "Taylor Rule が実証的には2%をターゲットとしていることと整合的でないことに注意してください. 定常状態のインフレ率が0でないと仮定する場合は, NKIS, NKPCの形は少し複雑になります. 詳しくは Ascari and Rossi (2012) を参照してください.↩︎\nAscari and Rossi (2012) の中で, Calvo型の価格改訂確率を \\(1-\\theta=0.25\\) とした場合, 対応するRotemberga型の価格改訂コストは \\(\\varphi=\\frac{(\\varepsilon-1)\\theta}{(1-\\theta)(1-\\beta\\theta)}\\).↩︎\n 解の唯一性と必要十分条件は, \\(\\phi_y, \\phi_{\\pi} &gt; 0\\) に対して, \\[\n  \\kappa(\\phi_{\\pi}-1) + (1-\\beta)\\phi_y &gt; 0.\n  \\] 導出は, Bullard and Mitra (2002) を参照してください.↩︎\n 対数線形化は一次近似に過ぎませんが, これらのパッケージではより高次の近似も可能です.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>New Keynesian</span>"
    ]
  },
  {
    "objectID": "03-dmp.html",
    "href": "03-dmp.html",
    "title": "3  Diamond-Mortensen-Pissarides Framework",
    "section": "",
    "text": "3.1 DMP Framework とは\nこれまで見たきたモデルでは, 摩擦のない労働市場を前提としていました. つまり, 全ての企業は労働者を雇うことができ, 労働者は均衡賃金で仕事を見つけられると仮定していました. しかし, 実際の労働市場では失業, 働きたいが仕事が見つからない, といった現象が観察されます. DMPモデルは, こうした摩擦のある労働市場を考慮し, 失業を内生化するモデルです.\nDMPモデルは, 今まで学んできた Solow, Ramsey, RBC, New Keynesian モデルの流れと直接のつながりがないため, 少し違和感を感じるかもしれません. しかし, その後の研究で, DMPモデルはこれら新古典派のモデルと組み合わされていき (Merz 1995; Andolfatto 1996), 代表的な研究として Krusell, Mukoyama, and Şahin (2010) のモデルがあります.\nちなみに, Diamond, Mortensen, Pissarides の3人は, 2010年にノーベル経済学賞を受賞しています.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>DMP Framework</span>"
    ]
  },
  {
    "objectID": "03-dmp.html#dmp-framework-とは",
    "href": "03-dmp.html#dmp-framework-とは",
    "title": "3  Diamond-Mortensen-Pissarides Framework",
    "section": "",
    "text": "図 3.1: Nobel Prize in Economic Science 2010.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>DMP Framework</span>"
    ]
  },
  {
    "objectID": "03-dmp.html#stylized-facts",
    "href": "03-dmp.html#stylized-facts",
    "title": "3  Diamond-Mortensen-Pissarides Framework",
    "section": "3.2 Stylized Facts",
    "text": "3.2 Stylized Facts\n失業の定義\n失業は16歳以上の労働力人口を以下の3つに分類して定義されます.\n\n\\(E\\): Employed. 仕事を持っている人\n\\(U\\): Unemployed. 仕事を持っていないが, 仕事を探している人\n\\(N\\): Not in the Labor Force. 仕事を持っておらず, 仕事も探していない人\n\n例えば, 学生や専業主婦, 引退した高齢者などが \\(N\\) に該当します. 失業率 \\(u_t\\) は以下のように定義されます.\n\\[\nu_t := \\frac{U_t}{E_t + U_t}\n\\]\n\n\n\n\n\n\n図 3.2: U.S. Bureau of Economics Analysis, Unemployment Rate UNRATE.\n\n\n\n図 3.2 はアメリカの失業率とNBERによる不況期間 (グレー) を示しています. 失業率は不況期に上昇し, 景気回復期に低下する傾向があることがわかります.1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>DMP Framework</span>"
    ]
  },
  {
    "objectID": "03-dmp.html#model",
    "href": "03-dmp.html#model",
    "title": "3  Diamond-Mortensen-Pissarides Framework",
    "section": "3.3 Model",
    "text": "3.3 Model\n\n3.3.1 設定\n\n労働者は Employed (\\(E\\)) か Unemployed (\\(U\\)) のいずれかの状態にある\nそれぞれの状態にある労働者の数を \\(e_t\\) と \\(u_t\\) とし, \\(e_t + u_t = 1\\)\n\\(E\\) から \\(U\\) への遷移確率を \\(\\sigma\\) とし, \\(U\\) から \\(E\\) への遷移確率を \\(\\lambda\\) とする\n\n\n\n\n\n\n\n図 3.3: Employment and Unemployment\n\n\n\nよって失業率 \\(u_t\\) の遷移は次のように表されます.\n\\[\nu_{t+1} = (1-\\lambda)u_t + \\sigma (1-u_t).\n\\]\nSteady state \\(u_{t+1} = u_t = \\overline{u}\\) について解くと, \\[\n\\overline{u} = \\frac{\\sigma}{\\lambda + \\sigma}.\n\\tag{3.1}\\]\n\n\n3.3.2 マッチング関数\n\n\n\n\n\n\nNoteマッチング関数\n\n\n\n\\(t\\) 時点における失業者の数を \\(u_t\\), 求人の数 (vacancy) を \\(v_t\\) とした時, \\(t+1\\) の始めにおけるマッチの数 \\(\\mathcal{M}_{t+1}\\) は次のように表されます.\n\\[\n\\mathcal{M}_{t+1} = M(u_t, v_t).\n\\]\nこのマッチング関数 \\(M(u, v)\\) は以下の性質を持ちます.\n\n\\(u, v\\) に対して単調増加\nConstant returns to scale\n\\(M(u, v) \\le u, v\\)\n\n\n\nこのマッチング関数は Blackbox な関数と言われます. 雇用に際しどのような要因でどのような摩擦があるのかなどに深入りせず, それらの摩擦を吸収した抽象的な関数として考えます.\n労働者 (worker) が企業にマッチする確率は \\(\\lambda_w\\) は以下のように表されます.\n\\[\n\\lambda_w(\\theta_t) = \\frac{M(u_t, v_t)}{u_t} = M\\left(1, \\frac{v_t}{u_t}\\right) = M(1, \\theta_t).\n\\]\nこの \\(\\theta_t := \\frac{v_t}{u_t}\\) は労働市場の逼迫性 (labor market tightness) と呼ばれます. 例えば, 労働市場がタイト, \\(\\theta_t\\) が大きい場合, 求人が多く失業者が少ないことを意味し, 雇い主は高い賃金を提示して雇用しなければなりません. 逆に, 労働市場が緩和, \\(\\theta_t\\) が小さい場合, 求人が少なく失業者が多いことを意味し, 雇い主は低い賃金でも労働者を雇うことができます. これを 式 3.1 に代入すると,\n\\[\n\\overline{u} = \\frac{\\sigma}{\\lambda_{w}(v / \\overline{u}) + \\sigma}\n\\]\nであり, 変形すると\n\\[\nM(\\overline{u}, v) + \\sigma \\overline{u} = \\sigma.\n\\tag{3.2}\\]\nこの関係から, \\(\\sigma\\) が定数であれば, (定常状態の) 失業率 \\(\\overline{u}\\) と 求人 \\(v\\) に負の関係があることがわかります. この関係を, ベバリッジ曲線 (Beveridge Curve) と呼びます.\nなお, 求人 \\(v_t\\) がマッチする確率を \\(\\lambda_f\\) とすると,\n\\[\n\\frac{M(u_t, v_t)}{v_t} = M\\left(\\frac{u_t}{v_t}, 1\\right) = M\\left(\\frac{1}{\\theta_t}, 1\\right) =: \\lambda_f(\\theta_t).\n\\]\n\n\n3.3.3 ベバリッジ曲線とシフト\n\n\n\n\n\n\n図 3.4: Beveridge Curve in the United States (Azzimonti et al. 2025, fig. 20.4)\n\n\n\n図 3.4 は2000年以降のアメリカのベバリッジ曲線を示しています. グラフの中で, 3つのベバリッジ曲線 Dec. 2000 - Oct. 2009, Oct. 2009 - Apr. 2020, Apr. 2020 - May 2022 とその間のシフトを見ることができます. シフトが起こった時期は, リーマンショックやCovid-19の影響を受けた時期です.\nベバリッジ曲線のシフトの一つの解釈はマッチング関数の変化です. 例えば, マッチング関数が以下のコブ・ダグラス型であるとすると\n\\[\nM(u, v) = \\chi u^\\eta v^{1-\\eta},\n\\tag{3.3}\\]\nベバリッジ曲線は以下のように表されます.\n\\[\nv = \\left(\\frac{\\sigma (1-\\overline{u})}{\\chi \\overline{u}^{\\eta}}\\right)^{\\frac{1}{1-\\eta}}.\n\\]\nマッチングのしやすさを表す \\(\\chi\\) が小さくなったとき, ベバリッジ曲線が上にシフトすることがわかります.\n\n\n3.3.4 労働市場均衡\nここで, 求人 \\(v_t\\) が決定する労働市場の均衡を考えます.\n企業\n\n無限期間の利益を最大化すると考える. 割引率を \\(\\beta \\in (0, 1)\\) とする\n\\(t\\) 期の生産を \\(z_t\\) とし, マルコフ過程に従うとする\n労働者に払う賃金を \\(w(z)\\) とする\n求人を出すコストを \\(\\kappa\\) とする\n\n十分な労働者がいる企業の価値関数を \\(J(z)\\), 求人を行う企業の価値関数を \\(V(z)\\) とすると\n\\[\n\\begin{aligned}\nJ(z) &= z - w(z) + \\beta \\mathbb{E}\\left[(1-\\sigma)J(z') + \\sigma V(z') \\mid z\\right] \\\\\nV(z) &= -\\kappa + \\beta \\mathbb{E}\\left[(1-\\lambda_f(\\theta))V(z') + \\lambda_f(\\theta) J(z') \\mid z\\right].\n\\end{aligned}\n\\tag{3.4}\\]\nここでは, 企業が労働者にマッチする確率を \\(\\lambda_f(\\theta)\\) とし,\n\\[\n\\lambda_f(\\theta) = \\frac{M(u, v)}{v} = M\\left(\\frac{u}{v}, 1\\right) = M\\left(\\frac{1}{\\theta}, 1\\right).\n\\]\nさらに, 求人はどの企業も自由に行うことができる (free entry) を仮定すると,\n\\[\nV(z) = 0.\n\\tag{3.5}\\]\nよって, 式 3.4 から\n\\[\n\\frac{\\kappa}{\\lambda_{f}(\\theta)} = \\beta \\mathbb{E}[J(z') | z].\n\\]\n直感的には, 求人を出すコスト \\(\\kappa\\) はマッチした時の期待値 \\(\\beta \\mathbb{E}[J(z') | z]\\) とマッチする確率 \\(\\lambda_{f}(\\theta)\\) の積で決まること解釈できます.\n労働者\n\n無限期間の線形効用を最大化すると考える. 割引率は \\(\\beta\\).\n雇用されている労働者の価値関数を \\(W(z)\\), 失業している労働者の価値関数を \\(U(z)\\) とする\n\n\\[\n\\begin{aligned}\nW(z) &= w(z) + \\beta \\mathbb{E}[(1-\\sigma)W(z') + \\sigma U(z') | z] \\\\\nU(z) &= b + \\beta \\mathbb{E}[\\lambda_w(\\theta)W(z') + (1-\\lambda_w(\\theta))U(z') | z].\n\\end{aligned}\n\\tag{3.6}\\]\n賃金交渉\n\nマッチした労働者と企業は賃金を交渉すると考える\n一般ナッシュ交渉を仮定する\n\n\\[\n\\max_{w} \\left(\\widetilde{W}(w, z) - U(z)\\right)^{\\gamma}\\left(\\widetilde{J}(w, z) - V(z)\\right)^{1-\\gamma}.\n\\]\nここで, \\(\\widetilde{W}(w, z)\\), \\(\\widetilde{J}(w, z)\\) は今期の賃金が \\(w\\) の時の労働者と企業の価値関数を表します. そのため, 今までの表現 \\(W(z), J(z)\\) は, 均衡賃金 \\(w(z)\\) をすでに考慮した書き方になっていたということです.\nここで, 一階条件をとると\n\\[\n(1-\\gamma)\\left(\\widetilde{W}(w, z) - U(z)\\right) = \\gamma \\left(\\widetilde{J}(w, z) - V(z)\\right).\n\\tag{3.7}\\]\n\\(U(z)\\), \\(V(z)\\) は労働者と企業からみた交渉決裂点 (disagreement point, outside option) であり, それと比べた場合の余剰 (surplus) を交渉力 \\(\\gamma\\), \\(1 - \\gamma\\) で重み付けて均等化しているということがわかります. もう一つの解釈は, 均衡における総余剰 \\(\\mathcal{S}\\) を以下のように定義した時,\n\\[\n\\mathcal{S}(z) = \\underbrace{W(z) - U(z)}_{\\text{Worker Surplus}} + \\underbrace{J(z) - V(z)}_{\\text{Firm Surplus}},\n\\]\n一階条件 式 3.7 は以下のように書き換えられます.\n\\[\n\\begin{aligned}\nW(z) &= U(z) + \\gamma \\mathcal{S}(z), \\\\\nJ(z) &= V(z) + (1-\\gamma) \\mathcal{S}(z).\n\\end{aligned}\n\\]\nつまり, 労働者と企業は outside option に加えて, 総余剰のそれぞれの交渉力に応じた部分を得ることができるという解釈です.\n均衡\n式 3.4, 式 3.5, 式 3.6, 式 3.7 によって均衡が定義されます. これらを整理すると, 次の Job Creation Condition (JC) が得られます.\n\\[\n\\frac{\\kappa}{(1-\\gamma)\\lambda_{f}(\\theta_t)} = \\beta \\mathbb{E}\\left[z_{t+1} - b + \\frac{1-\\sigma-\\gamma\\lambda_w(\\theta_{t+1})}{1-\\gamma}\\frac{\\kappa}{\\lambda_{f}(\\theta_{t+1})}\\right].\n\\tag{3.8}\\]\n導出は 命題 B.4 を参照してください. ここで定常状態を考えると,\n\\[\n\\frac{\\kappa}{(1-\\gamma)\\lambda_{f}(\\overline{\\theta})} = \\beta \\left(\\overline{z} - b + \\frac{1-\\sigma-\\gamma\\lambda_w(\\overline{\\theta})}{1-\\gamma}\\frac{\\kappa}{\\lambda_{f}(\\overline{\\theta})}\\right).\n\\tag{3.9}\\]\n式 3.9 は定常状態の \\(\\overline{\\theta} = \\frac{\\overline{v}}{\\overline{u}}\\) を定める式とみなすことができます. したがって, 均衡における求人 \\(v\\) と失業率 \\(u\\) の関係は, 式 3.2 (BC) と 式 3.9 (JC) の交点によって決定されます.\n\n\n\n\n\n\n\n\nDetermination of Steady State\n\n\n\n\n\n\n\nTransition of Steady State\n\n\n\n\n\n\n図 3.5: Figure 20.5 and 20.6 from Azzimonti et al. (2025).\n\n\n\n図 3.5 の左図は, \\(BC\\) と \\(JC_1\\) の交点によって失業率 \\(\\overline{u}\\) と求人 \\(\\overline{v}\\) が決定される様子を示しています (\\(SS_1\\)).\nここで予期しない恒常的な生産性の低下, \\(\\overline{z}\\) が下がったとします. すると 式 3.9 から \\(\\overline{\\theta}\\) が下がり, \\(JC_1\\) から \\(JC_2\\) へシフトします. この時, 移行過程では右図のような変化が起きると考えることができます. 失業率 \\(u\\) はすぐには変化できないため, 求人 \\(v\\) が大きく低下します. その後, 失業率 \\(u\\) が徐々に上昇し, 新しい均衡点 \\(SS_2\\) に到達します.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>DMP Framework</span>"
    ]
  },
  {
    "objectID": "03-dmp.html#calibration",
    "href": "03-dmp.html#calibration",
    "title": "3  Diamond-Mortensen-Pissarides Framework",
    "section": "3.4 Calibration",
    "text": "3.4 Calibration\n\n3.4.1 Functional Forms\nマッチング関数は 式 3.3 で表されると仮定し, 生産 \\(z_t\\) は以下のように表されるとします.\n\\[\n\\hat{z}_{t+1} = \\rho \\hat{z}_t + \\varepsilon_{t+1}\n\\]\nここで, \\(\\hat{z}_{t}\\) は steady state \\(\\overline{z}\\) からの log-deviation, つまり\n\\[\n\\hat{z}_{t} = \\log z_t - \\log \\overline{z}.\n\\]\n\n\n3.4.2 Parameter Values\nモデルのパラメータは先行研究に従い, 以下のように設定します.\n\n\n\n表 3.1: Parameter values for the DMP model\n\n\n\n\n\n\n\n\n\n\nParameter\nValue\nSource\n\n\n\n\n\\(\\beta\\)\n0.996\nCooley and Prescott (1995)\n\n\n\\(\\rho\\)\n0.949\nHagedorn and Manovskii (2008)\n\n\n\\(\\sigma_{\\varepsilon}\\)\n0.0065\nHagedorn and Manovskii (2008)\n\n\n\\(\\sigma\\)\n0.034\nShimer (2005)\n\n\n\\(\\chi\\)\n0.45\nShimer (2005)\n\n\n\\(b\\)\n0.4\nShimer (2005)\n\n\n\\(\\gamma\\)\n0.72\nShimer (2005)\n\n\n\\(\\eta\\)\n0.72\nShimer (2005)\n\n\n\n\n\n\n\nモデルの一期間は１ヶ月とする (Hagedorn and Manovskii (2008) では1週間)\nRBCモデルで標準的な1年の割引率 \\(\\beta = 0.947\\) (Cooley and Prescott 1995) を1ヶ月に直すと \\(0.947^{\\frac{1}{12}} = 0.996\\)\n定常状態において \\(\\overline{z} = 1, \\overline{\\theta} = 1\\) とする\n\\(\\kappa\\) の値は定常状態 式 3.9 を用いて次のように計算される\n\n\\[\n\\kappa = \\frac{(1-\\gamma) \\lambda_{f}(\\overline{\\theta}) \\beta (\\overline{z} - b)}{1 - \\beta (1 - \\sigma - \\gamma \\lambda_{w}(\\overline{\\theta}))}.\n\\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>DMP Framework</span>"
    ]
  },
  {
    "objectID": "03-dmp.html#simulation",
    "href": "03-dmp.html#simulation",
    "title": "3  Diamond-Mortensen-Pissarides Framework",
    "section": "3.5 Simulation",
    "text": "3.5 Simulation\n\n\nCode\n@model DMP begin\n    κ / ((1 - γ) * λ_f[0]) =\n        β * (z[1] - b + (1 - σ - γ * λ_w[1]) / (1 - γ) * (κ / λ_f[1]))\n    λ_f[0] = χ * θ[0]^(-η)\n    λ_w[0] = χ * θ[0]^(1 - η)\n    u[0] = (1 - λ_w[-1]) * u[-1] + σ * (1 - u[-1])\n    v[0] = θ[0] * u[0]\n    log(z[0]) - log(z̄) = ρ * (log(z[-1]) - log(z̄)) + σ_ε * ε[x]\nend\n\n@parameters DMP begin\n    β = 0.996\n    ρ = 0.949\n    σ_ε = 0.0065\n    σ = 0.034\n    χ = 0.45\n    b = 0.4\n    γ = 0.72\n    η = 0.72\n    z̄ = 1.0\n    θ̄ = 1.0\n    λ̄_w = χ * θ̄^(1 - η)\n    κ = (1 - γ) * λ̄_w * β * (z̄ - b) / (1 - β * (1 - σ - γ * λ̄_w))\nend\n\n\n\n\nCode\nplot_irf(DMP, variables=[:u, :v, :z, :θ], periods=100);\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n図 3.6: Impulse Response Functions of the DMP Model\n\n\n\n\n\n\nirf = FileAttachment(\"output/dmp_irf.csv\").csv({ typed: true })\nbc = FileAttachment(\"output/dmp_bc.csv\").csv({ typed: true })\nu_min = -0.3\nu_max = 0.3\n\njc = [{u: u_min, v: u_min}, {u: u_max, v: u_max}]\n\nPlot.plot({\n  style: {fontSize: \"16px\"},\n  grid: true,\n  marks: [\n    Plot.line(bc, {x: \"u\", y: \"v\", stroke: \"gray\", strokeDasharray: \"4,4\"}),\n    Plot.text([{u: 0.3, v: -0.6}], {x: \"u\", y: \"v\", text: [\"BC\"], dy: 20}),\n    Plot.line(jc, {x: \"u\", y: \"v\", stroke: \"gray\", strokeDasharray: \"2,2\"}),\n    Plot.text([{u: 0.3, v: 0.4}], {x: \"u\", y: \"v\", text: [\"JC\"], dy: 10}),\n    Plot.line(irf, {filter: d =&gt; d.t &gt;= 0 && d.t &lt;= t, x: \"u\", y: \"v\", stroke: \"#c2676d\"}),\n    Plot.dot(irf, {filter: d =&gt; d.t === t, x: \"u\", y: \"v\", fill: \"#c2676d\", r: 5}),\n    Plot.text(irf, {filter: d =&gt; d.t === t, x: \"u\", y: \"v\", text: d =&gt; `t=${d.t}`, dy: -10}),\n    Plot.dot([{u: 0, v: 0}], {x: \"u\", y: \"v\", fill: \"#0f6a81\", r: 5}),\n    Plot.text([{u: 0, v: -0.1}], {x: \"u\", y: \"v\", text: [\"SS\"], dy: 10})\n  ],\n  x: {label: \"Unemployment (%Δ)\", domain: [u_min, u_max], labelOffset: 1},\n  y: {label: \"Vacancy (%Δ)\", domain: [-1, 1], labelOffset: 1}\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof t = Inputs.range([-1, 99], {label: \"t =\", step: 1, value: -1})\n\n\n\n\n\n\n\n\n\n3.5.1 Summary Statistics\n\n\n\n表 3.2: Summary Statistics for Quarterly U.S. Data from 1951 I to 2004 IV. (Azzimonti et al. 2025, Table 19.2)\n\n\n\n\n\n\n\nCode\nfunction sim_one(; burnin, periods, mdl)\n    sim = get_simulation(mdl, variables=[:u, :v, :z, :θ], periods=periods + burnin, levels=true)\n    us = sim(:u, burnin+1:burnin+periods, :simulate)\n    vs = sim(:v, burnin+1:burnin+periods, :simulate)\n    zs = sim(:z, burnin+1:burnin+periods, :simulate)\n    θs = sim(:θ, burnin+1:burnin+periods, :simulate)\n\n    xs_quarterly = [[mean(xs[i:i+2]) for i in 1:3:length(xs)-3] for xs in (us, vs, θs, zs)]\n    cycles = [hp_filter(log.(xs), 1600)[1] for xs in xs_quarterly]\n\n    std_mdl = [std(xs) for xs in cycles]\n    acor_mdl = [cor(xs[2:end], xs[1:end-1]) for xs in cycles]\n    cor_mdl = vcat([cor(cycles[1], cycles[i]) for i in 2:4],\n        [cor(cycles[2], cycles[i]) for i in 3:4],\n        [cor(cycles[3], cycles[4])])\n\n    df = DataFrame(\n        pars=[\"std_u\", \"std_v\", \"std_θ\", \"std_z\",\n            \"acor_u\", \"acor_v\", \"acor_θ\", \"acor_z\",\n            \"cor_uv\", \"cor_uθ\", \"cor_uz\", \"cor_vθ\", \"cor_vz\", \"cor_θz\"],\n        value=vcat(std_mdl, acor_mdl, cor_mdl))\nend\n\nfunction get_table(; n_sim=1000, burnin=100, periods=648, mdl=DMP)\n    df = sim_one(burnin=burnin, periods=periods, mdl=mdl)\n    for i in 2:n_sim\n        df_i = sim_one(burnin=burnin, periods=periods, mdl=mdl)\n        df = vcat(df, df_i)\n    end\n\n    res = combine(groupby(df, :pars),\n        [:value] .=&gt; mean .=&gt; [:value]\n    )[!, :value]\n\n    tb = DataFrame(\n        desc=[\"Standard Deviation\", \"Quartely Autocorrelation\", missing,\n            \"Correlation Matrix\", missing, missing],\n        tmp=[\"\", \"\", \"\\$u\\$\", \"\\$v\\$\", \"\\$v/u\\$\", \"\\$z\\$\"],\n        u=[res[1], res[5], 1, missing, missing, missing],\n        v=[res[2], res[6], res[9], 1, missing, missing],\n        θ=[res[3], res[7], res[10], res[12], 1, missing],\n        z=[res[4], res[8], res[11], res[13], res[14], 1]\n    )\n\n    return tb\nend\n\ndf_mdl = get_table()\npretty_table(df_mdl, backend=:markdown, allow_markdown_in_cells=true,\n    alignment=[:l, :c, :r, :r, :r, :r],\n    column_labels=[\"\", \"\", \"\\$u\\$\", \"\\$v\\$\", \"\\$v/u\\$\", \"\\$z\\$\"],\n    formatters=[\n        (v, i, j) -&gt; ismissing(v) ? \"\" : v,\n        (v, i, j) -&gt; v isa Number ? @sprintf(\"%.3f\", v) : v\n    ]\n)\n\n\n\n\n表 3.3: Model Statistics\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(u\\)\n\\(v\\)\n\\(v/u\\)\n\\(z\\)\n\n\n\n\nStandard Deviation\n\n0.005\n0.015\n0.019\n0.013\n\n\nQuartely Autocorrelation\n\n0.805\n0.670\n0.738\n0.738\n\n\n\n\\(u\\)\n1.000\n-0.822\n-0.893\n-0.894\n\n\nCorrelation Matrix\n\\(v\\)\n\n1.000\n0.990\n0.990\n\n\n\n\\(v/u\\)\n\n\n1.000\n1.000\n\n\n\n\\(z\\)\n\n\n\n1.000\n\n\n\n\n\n\n表 3.3 はシミュレーションの結果を示しています. 表 3.2 と比較すると, 各パラメータの相関はおおむね一致しています. しかし, \\(u, v, \\theta = v/u\\) の標準偏差が実際のデータよりも小さくなっていることがわかります. この点は, DMPモデルの重要な課題の一つとして知られており, “Labor Market Volatility Puzzle”, あるいは Shimer Puzzle (Shimer 2005) と呼ばれます.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>DMP Framework</span>"
    ]
  },
  {
    "objectID": "03-dmp.html#rbc-meets-dmp",
    "href": "03-dmp.html#rbc-meets-dmp",
    "title": "3  Diamond-Mortensen-Pissarides Framework",
    "section": "3.6 RBC meets DMP",
    "text": "3.6 RBC meets DMP\nここからは, RBCモデルにDMPフレームワークを組み込んだモデルを考えます. 次の3つが大きな違いです.\n\n凹型の効用関数\n生産関数に資本を導入\n企業の利潤を所有者に帰属2\n\n\n3.6.1 設定\n\n消費者は \\((i, j) \\in [0, 1]^2\\) のユニットスクエアに分布している\n\\(i\\) は家族を表し, \\(j\\) は家族内の個人を表す. 家族のメンバーは同一であると考える\n家族 \\(i\\) は互いに同一であると考える. したがって, 代表的家族 (representative family) を考えることができる\n家族内の所得はプールされ, 消費は均等に分配されると考える. したがって, 世帯主 (household head) の効用を最大化することを考える\n\n家計\n代表的家計の世帯主の問題を考えるため, \\(i, j\\) を省略します.\n\\[\n\\max_{\\{c_t\\}} \\mathbb{E}_0 \\sum_{t=0}^{\\infty} \\beta^t \\mathcal{U}(c_t)\n\\]\nsubject to\n\\[\nc_t + k_{t+1} = (1+r_t - \\delta) k_t + (1-u_t) w_t + u_t b + d_t\n\\]\n\n\\(u_t\\): 失業率. 家族の中にいる失業者の割合\n\\(b\\): 失業給付 (unemployment benefit) または home production\n\\(d_t\\): 企業からの配当 (dividend)\n\n企業\n代表的企業の生産関数は次のコブ・ダグラス型とします.\n\\[\nY_t = z_t K_t^{1-\\alpha} N_t^{\\alpha}.\n\\]\nなお, 労働投入量は雇用数と一致するため \\(N_t = 1 - u_t\\) です. ここで, 労働者一人あたりの資本投入量を \\(k_{f, t} := \\frac{K_t}{1-u_t}\\) とすると, 企業の最適資本量選択問題は次のように表されます.\n\\[\n\\max_{k_{f, t}} z_t k_{f, t}^{\\alpha} - r_t k_{f, t}\n\\]\n一階条件より \\(r_t = \\alpha z_t k_{f, t}^{\\alpha - 1}\\) となり, 均衡における資本価格は次のように表されます.\n\\[\nr(z_t, K_t, u_t) = \\alpha z_t \\left(\\frac{K_t}{1-u_t}\\right)^{\\alpha - 1}.\n\\]\nここで, 状態変数を \\(X_t := (z_t, K_t, u_t)\\) と定義し, マッチごとの企業余剰を \\(y(X_t)\\) と表すと,\n\\[\n\\begin{aligned}\ny(X_t) &= z_t \\left(\\frac{K_t}{1-u_t}\\right)^{\\alpha} - r(X_t) \\frac{K_t}{1-u_t} \\\\\n&= (1-\\alpha) z_t \\left(\\frac{K_t}{1-u_t}\\right)^{\\alpha}.\n\\end{aligned}\n\\]\n\n\n3.6.2 ベルマン方程式\n家計\n\\[\n\\mathcal{V}(k, X) = \\max_{c, k'} \\mathcal{U}(c) + \\beta \\mathbb{E}\\left[\\mathcal{V}(k', X') | z\\right]\n\\]\nsubject to\n\\[\n\\begin{aligned}\nc + k' &= (1 + r(X) - \\delta) k + (1-u) w(X) + u b + d(X), \\\\\nK' &= \\Omega(X), \\\\\nu' &= (1 - \\lambda_w(\\theta(X))) + \\sigma (1 - u).\n\\end{aligned}\n\\]\nここで \\(\\Omega(X)\\) は資本蓄積の法則 (Law of motion of capital) を表します. また, \\(w(X), d(X)\\) はそれぞれ均衡賃金と企業の配当を表します. ここから, 状態価格 (state price) が導けます.\n\\[\nQ(z', X) = \\beta f(z' | z) \\frac{\\mathcal{U}_c(C(z', \\Omega(X), u'(X)))}{\\mathcal{U}_c(C(X))}\n\\]\nここで, \\(f(z' | z)\\) は状態 \\(z\\) から次期の状態 \\(z'\\) への遷移確率密度関数を表します. \\(Q(z', X)\\) の解釈としては\n\n次の期に \\(z'\\) が実現した時に, 1単位の消費をもらえる保険 (Arrow security) の価格\n各状態 \\(z'\\) に対する確率的割引因子\n\nこの状態価格を導入すると, 労働者や企業の価値関数が \\(Q(z', X)\\) を用いた形でかけます. それぞれの導出は Azzimonti et al. (2025) の Chapter 20 とその付録を参照してください.\n労働者\n家族にとって, 家族のメンバー (労働者) は, 確率的に雇用状態の変化する所得の過程とみなすことができます. したがって, 労働者の価値関数は \\(Q(z', X)\\) を用いて次のように表されます.\n\\[\n\\begin{aligned}\nW(X) &= w(X) + \\int Q(z', X)\\left((1-\\sigma)W(X') + \\sigma U(X')\\right)\\, dz' \\\\\nU(X) &= b + \\int Q(z', X)\\left(\\lambda_w(\\theta(X))W(X') + (1-\\lambda_w(\\theta(X)))U(X')\\right)\\, dz'\n\\end{aligned}\n\\tag{3.10}\\]\n導出の詳細は Azzimonti et al. (2025) の付録20.A.6 を参照してください.\n企業\n企業の価値関数も同様にして次のように表されます.\n\\[\n\\begin{aligned}\nJ(X) &= y(X) - w(X) + \\int Q(z', X)\\left((1-\\sigma)J(X') + \\sigma V(X')\\right)\\, dz' \\\\\nV(X) &= -\\kappa + \\int Q(z', X)\\left((1-\\lambda_f(\\theta(X)))V(X') + \\lambda_f(\\theta(X)) J(X')\\right)\\, dz'\n\\end{aligned}\n\\tag{3.11}\\]\n導出の詳細は Azzimonti et al. (2025) の付録20.A.6 を参照してください. また, Free entry condition \\(V(X) = 0\\) から,\n\\[\n\\frac{\\kappa}{\\lambda_f(\\theta(X))} = \\int Q(z', X) J(X')\\, dz'.\n\\tag{3.12}\\]\n\n\n3.6.3 Equilibrium Conditions\nJob Creation Condition\n式 3.10, 式 3.11, 式 3.12 から, 命題 B.4 と同様にして, Job Creation Condition が導出されます.\n\\[\n\\frac{\\kappa}{(1-\\gamma)\\lambda_{f}(\\theta(X))} = \\int Q(z', X) \\left[y(X') - b + \\frac{1-\\sigma-\\gamma\\lambda_w(\\theta(X'))}{1-\\gamma}\\frac{\\kappa}{\\lambda_{f}(\\theta(X'))}\\right]\\, dz'.\n\\tag{3.13}\\]\nEuler Equation\n標準的なRBCモデルであるため, 家計の最適化条件から Euler Equation が導出されます.\n\\[\n1 = \\int Q(z', X) (1 + r(X') - \\delta)\\, dz'.\n\\]\nResource Constraint\n\\[\nK' = (1 - \\delta) K + Y - C - \\kappa v\n\\]\n\nVacancy cost \\(\\kappa v\\) は財で支払われると仮定\n人口が1であるため, 総消費 \\(C\\) は一人当たり消費 \\(c\\) と一致\n\n\n\n\n\n\n\n\nAndolfatto, David. 1996. “Business Cycles and Labor-Market Search.” The American Economic Review 86 (1): 112–32. https://www.jstor.org/stable/2118258.\n\n\nAzzimonti, Marina, Per Krusell, Alisdair McKay, and Toshihiko Mukoyama. 2025. Macroeconomics.\n\n\nCooley, Thomas F., and Edward C. Prescott. 1995. “Economic Growth and Business Cycles.” In Frontiers of Business Cycle Research, edited by Thomas F. Cooley, 1–38. Princeton University Press. https://doi.org/10.2307/j.ctv14163jx.7.\n\n\nHagedorn, Marcus, and Iourii Manovskii. 2008. “The Cyclical Behavior of Equilibrium Unemployment and Vacancies Revisited.” American Economic Review 98 (4): 1692–1706. https://doi.org/10.1257/aer.98.4.1692.\n\n\nKrusell, Per, Toshihiko Mukoyama, and Ayşegül Şahin. 2010. “Labour-Market Matching with Precautionary Savings and Aggregate Fluctuations.” Review of Economic Studies 77 (4): 1477–507. https://doi.org/10.1111/j.1467-937X.2010.00700.x.\n\n\nMerz, Monika. 1995. “Search in the Labor Market and the Real Business Cycle.” Journal of Monetary Economics 36 (2): 269–300. https://doi.org/10.1016/0304-3932(95)01216-8.\n\n\nShimer, Robert. 2005. “The Cyclical Behavior of Equilibrium Unemployment and Vacancies.” American Economic Review 95 (1): 25–49. https://doi.org/10.1257/0002828053828572.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>DMP Framework</span>"
    ]
  },
  {
    "objectID": "03-dmp.html#footnotes",
    "href": "03-dmp.html#footnotes",
    "title": "3  Diamond-Mortensen-Pissarides Framework",
    "section": "",
    "text": "NBERのBusiness Cycle Dating には雇用に関する指数も含まれているため, ある意味当然の結果とも言えます.↩︎\n今までは企業はこの経済の外部から所有されていると暗に仮定していました.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>DMP Framework</span>"
    ]
  },
  {
    "objectID": "11-linearization.html",
    "href": "11-linearization.html",
    "title": "Appendix A — Linearization",
    "section": "",
    "text": "A.1 対数変化率\nこの時, \\(\\hat{x}_t\\) を定常状態 \\(x\\) からの対数変化率とすると:\n\\[\n\\begin{aligned}\n\\hat{x}_t &:= \\log x_t - \\log x \\\\\n&= \\log\\left(\\frac{x_t}{x}\\right) \\\\\n&= \\log\\left(1 + \\frac{x_t - x}{x}\\right) \\\\\n&\\approx \\frac{x_t - x}{x} \\\\\n\\end{aligned}\n\\]\nこの, \\(\\frac{x_t - x}{x}\\) という量は, 定常状態 \\(x\\) からの変化率を表す量です. したがって, \\(\\hat{x}_t = 0.01\\) であれば, 定常状態 \\(x\\) から1%の変化があったことを意味します. 論文によって, \\(\\hat{x}_t := \\log x_t - \\log x\\) と定義するか, \\(\\hat{x}_t := \\frac{x_t - x}{x}\\) と定義するかは異なりますが, 近似的にはどちらも同じ意味持ちます.\nCode\nx = 1.\nxₜs = x .+ (-0.05:0.01:0.05)\nplot(xₜs, xₜ -&gt; (xₜ - x) / x, label=L\"\\frac{x_t - x}{x}\",\n    xlabel=L\"x_t\", ylabel=L\"\\hat{x}_t\", size=(500, 309))\nplot!(xₜs, xₜ -&gt; log(xₜ) - log(x), label=L\"\\log x_t - \\log x\")\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 A.1: Approximation of the deviation from the steady state\n図 A.1 にあるように, \\(\\hat{x}_t\\) は定常状態 \\(x\\) に十分近ければ, どちらの定義もほとんど同じ値をとることがわかります.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Linearization</span>"
    ]
  },
  {
    "objectID": "11-linearization.html#対数変化率",
    "href": "11-linearization.html#対数変化率",
    "title": "Appendix A — Linearization",
    "section": "",
    "text": "命題 A.1 ある実数 \\(m\\) が0に近い時, 以下の近似が成り立つ.\n\\[\n\\log(1 + m) \\approx m.\n\\]\n\n\n\n\n\n\n\n定理 A.1 (1次近似) 1変数関数 \\(f\\) の点 \\(x\\) において, 以下が成り立つ.\n\\[\nf(x_t) = f(x) + f'(x)(x_t - x) + R(x_t).\n\\]\nここで, \\(R(x_t)\\) は高次の剰余項であり, \\(\\lim_{x_t \\rightarrow x} \\frac{R(x_t)}{ |x_t - x| } = 0\\) が成り立つ. したがって, \\(x\\) の近傍では剰余項が十分小さいため, 以下の近似が成り立つ.\n\\[\nf(x_t) \\approx f(x) + f'(x)(x_t - x).\n\\]\n多変数関数 \\(f: \\mathbb{R}^n \\rightarrow \\mathbb{R}\\) の場合も同様に近似できる.\n\\[\nf(\\mathbf{x}_t) \\approx f(\\mathbf{x}) + \\sum_{i=1}^n \\frac{\\partial f}{\\partial x_i}(\\mathbf{x})(x_{t,i} - x_i).\n\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Linearization</span>"
    ]
  },
  {
    "objectID": "11-linearization.html#対数線形化",
    "href": "11-linearization.html#対数線形化",
    "title": "Appendix A — Linearization",
    "section": "A.2 対数線形化",
    "text": "A.2 対数線形化\n\n命題 A.2 (対数線形化の一般形) \\(y_t = f(\\mathbf{x}_t)\\) の \\(\\mathbf{x}\\) 近傍での線形化は以下のように表される.\n\\[\n\\hat{y}_t = \\sum_{i=1}^n \\frac{\\partial f}{\\partial x_i}(\\mathbf{x})\\frac{x_i}{f(\\mathbf{x})}\\hat{x}_{i, t}.\n\\]\n\n証明\nStep 1: 両辺の対数をとる.\n\\[\n\\log y_t = \\log f(\\mathbf{x}_t)\n\\]\nStep 2: 両辺をそれぞれ一次近似する.\n\\[\n\\begin{aligned}\nLHS &\\approx \\log y + \\underbrace{\\frac{1}{y}(y_t - y)}_{\\hat{y}_t} \\\\\nRHS &\\approx \\log f(\\mathbf{x}) + \\sum_{i=1}^n \\frac{\\partial f}{\\partial x_i}(\\mathbf{x})\\frac{1}{f(\\mathbf{x})}(x_{i, t} - x_i) \\\\\n&= \\log f(\\mathbf{x}) + \\sum_{i=1}^n \\frac{\\partial f}{\\partial x_i}(\\mathbf{x})\\frac{x_i}{f(\\mathbf{x})}\\underbrace{\\frac{x_{i, t} - x_i}{x_i}}_{\\hat{x}_{i, t}}.\n\\end{aligned}\n\\]\nStep 3: 定常状態 \\(\\log y = \\log f(\\mathbf{x})\\) を両辺から引く.\n\\[\n\\hat{y}_t = \\sum_{i=1}^n \\frac{\\partial f}{\\partial x_i}(\\mathbf{x})\\frac{x_i}{f(\\mathbf{x})}\\hat{x}_{i, t}.\n\\]\n\nA.2.1 例\n\n例 A.1 (Cobb-Douglas Production Function) \\[\nY_t = A_t K_t^{\\alpha} L_t^{1 - \\alpha} \\Rightarrow\n\\hat{Y}_t \\approx \\hat{A}_t + \\alpha \\hat{K}_t + (1 - \\alpha) \\hat{L}_t.\n\\]\n\n\nProof. \n\nLogをとる\n\n\\(\\log Y_t = \\log A_t + \\alpha \\log K_t + (1-\\alpha)\\log L_t\\)\n\n線形近似\n\n\\(LHS = \\log Y + \\hat{Y_t}\\)\n\\(RHS = \\log A + \\alpha \\log K + (1-\\alpha)\\log L + \\hat{A}_t + \\alpha \\hat{K}_t + (1-\\alpha) \\hat{L}_t\\)\n\n定常状態を引く\n\n\\(\\hat{Y}_t = \\hat{A}_t + \\alpha \\hat{K}_t + (1 - \\alpha) \\hat{L}_t\\)\n\n\n\n\n例 A.2 (Ramsey Model) \\[\n\\begin{aligned}\n&c_t^{-\\sigma} = \\beta(1-\\delta+\\alpha k_{t}^{\\alpha-1})c_{t+1}^{-\\sigma} \\\\\n& k_t^\\alpha + (1-\\delta)k_t = c_t + k_{t+1}\n\\end{aligned}\n\\quad\\Rightarrow\\quad\n\\begin{aligned}\n\\hat{c}_{t+1} &= \\hat{c}_t + \\frac{\\beta \\alpha (\\alpha-1)k^{\\alpha-1}}{\\sigma} \\hat{k}_t \\\\\n\\hat{k}_{t+1} &= -\\frac{c}{k} \\hat{c}_t + \\frac{1}{\\beta} \\hat{k}_t.\n\\end{aligned}\n\\]\n\n\nProof.  Step 1: Logをとる\n\\[\n\\begin{aligned}\n-\\sigma \\log c_t &= \\log \\beta + \\log(1-\\delta+\\alpha k_{t}^{\\alpha-1}) - \\sigma \\log c_{t+1} \\\\\n\\log (k_t^{\\alpha} + (1-\\delta)k_t) &= \\log (c_t + k_{t+1})\n\\end{aligned}\n\\]\nStep 2: 線形近似\n\\[\n\\begin{aligned}\nLHS_1 &\\approx -\\sigma \\hat{c}_t + LHS_1^*\\\\\nRHS_1 &\\approx \\frac{\\alpha(\\alpha-1)k^{\\alpha-1}}{1-\\delta + \\alpha k^{\\alpha-1}}\\hat{k}_{t} +\n- \\sigma \\hat{c}_{t+1} + RHS_1^*\\\\\nLHS_2 &\\approx \\frac{\\alpha k^{\\alpha-1} + 1 - \\delta}{k^{\\alpha} + (1-\\delta)k} k\\hat{k}_t + LHS_2^*\\\\\nRHS_2 &\\approx \\frac{c}{c + k} \\hat{c}_t + \\frac{k}{c + k} \\hat{k}_{t+1} + RHS_2^*\n\\end{aligned}\n\\]\nなお, \\(LHS_1^*, RHS_1^*, LHS_2^*, RHS_2^*\\) は定常状態における値 (次のステップで消去される).\nStep 3: 定常状態を引く\n\\[\n\\begin{aligned}\n-\\sigma \\hat{c}_t &= \\frac{\\alpha(\\alpha-1)k^{\\alpha-1}}{1-\\delta + \\alpha k^{\\alpha-1}}\\hat{k}_{t} - \\sigma \\hat{c}_{t+1} \\\\\n\\frac{\\alpha k^{\\alpha-1} + 1 - \\delta}{k^{\\alpha} + (1-\\delta)k}k \\hat{k}_t &= \\frac{c}{c + k} \\hat{c}_t + \\frac{k}{c + k} \\hat{k}_{t+1}\n\\end{aligned}\n\\]\nなお, 定常状態では\n\\[\n\\begin{aligned}\nc^{-\\sigma} &= \\beta(1-\\delta+\\alpha k^{\\alpha-1})c^{-\\sigma} \\\\\nk^\\alpha + (1-\\delta)k &= c + k\n\\end{aligned}\n\\]\nが成り立つため, 整理すると以下を得ます.\n\\[\n\\begin{aligned}\n\\hat{c}_{t+1} &= \\hat{c}_t + \\frac{\\beta \\alpha (\\alpha-1)k^{\\alpha-1}}{\\sigma} \\hat{k}_t \\\\\n\\hat{k}_{t+1} &= -\\frac{c}{k} \\hat{c}_t + \\frac{1}{\\beta} \\hat{k}_t.\n\\end{aligned}\n\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Linearization</span>"
    ]
  },
  {
    "objectID": "11-linearization.html#対数線形化のもう一つの方法",
    "href": "11-linearization.html#対数線形化のもう一つの方法",
    "title": "Appendix A — Linearization",
    "section": "A.3 対数線形化のもう一つの方法",
    "text": "A.3 対数線形化のもう一つの方法\n\\(y_t = f(\\mathbf{x}_t)\\) の対数線形化は以下のように行うこともできます. この場合は, \\(\\hat{z}_t := \\log x_t - \\log x\\) と定義します.\nStep 1: \\(z_t = \\exp(\\log z_t)\\) と置き換える.\n\\[\n\\exp(\\log y_t) = f(\\exp(\\log \\mathbf{x}_t)).\n\\]\nStep 2: \\(\\log z_t\\) に対しての線形近似を行う.\n\\[\n\\begin{aligned}\nLHS &\\approx \\exp(\\log y) + \\exp(\\log y)(\\log y_t - \\log y) = y + y \\hat{y}_t \\\\\nRHS &\\approx f(\\exp(\\log \\mathbf{x})) + \\sum_{i=1}^n \\frac{\\partial f}{\\partial \\log x_i}(\\exp(\\log \\mathbf{x}))(\\log x_{i, t} - \\log x_i) \\\\\n&= f(\\mathbf{x}) + \\sum_{i=1}^n \\frac{\\partial f}{\\partial x_i}(\\mathbf{x})\\frac{\\partial x_i}{\\partial \\log x_i}(\\log x_{i, t} - \\log x_i) \\\\\n&= f(\\mathbf{x}) + \\sum_{i=1}^n \\frac{\\partial f}{\\partial x_i}(\\mathbf{x})x_i\\hat{x}_{i, t}.\n\\end{aligned}\n\\]\nStep 3: 両辺から定常状態 \\(y = f(\\mathbf{x})\\) を引き, 定常状態で割る.\n\\[\n\\hat{y}_t = \\sum_{i=1}^n \\frac{\\partial f}{\\partial x_i}(\\mathbf{x})\\frac{x_i}{f(\\mathbf{x})}\\hat{x}_{i, t}.\n\\]\nよって, この方法でも同じ結果が得られます.\n\n例 A.3 (Ramsey Model) \\[\n\\begin{aligned}\n&c_t^{-\\sigma} = \\beta(1-\\delta+\\alpha k_{t}^{\\alpha-1})c_{t+1}^{-\\sigma} \\\\\n& k_t^\\alpha + (1-\\delta)k_t = c_t + k_{t+1}\n\\end{aligned}\n\\quad\\Rightarrow\\quad\n\\begin{aligned}\n\\hat{c}_{t+1} &= \\hat{c}_t + \\frac{\\beta \\alpha (\\alpha-1)k^{\\alpha-1}}{\\sigma} \\hat{k}_t \\\\\n\\hat{k}_{t+1} &= -\\frac{c}{k} \\hat{c}_t + \\frac{1}{\\beta} \\hat{k}_t.\n\\end{aligned}\n\\]\n\n\nProof. \nStep 1: 置き換え\n\\[\n\\begin{aligned}\n&\\exp(-\\sigma \\log c_t) = \\beta(1-\\delta+\\alpha \\exp((\\alpha-1)\\log k_{t}))\\exp(-\\sigma \\log c_{t+1}) \\\\\n&  \\exp(\\alpha \\log k_t) + (1-\\delta)\\exp(\\log k_t) = \\exp(\\log c_t) + \\exp(\\log k_{t+1})\n\\end{aligned}\n\\]\nStep 2: 線形近似\n\\[\n\\begin{aligned}\nLHS_1 &\\approx LHS_1^* + \\exp(-\\sigma \\log c)(-\\sigma)(\\log c_t - \\log c) \\\\\n&= LHS_1^* - \\sigma c^{-\\sigma} \\hat{c}_t \\\\\nRHS_1 &\\approx RHS_1^* + \\beta \\alpha(\\alpha-1)\\exp(-\\sigma \\log c)\\exp((\\alpha-1)\\log k)(\\log k_t - \\log k) \\\\\n&+\\beta (1-\\delta+\\alpha \\exp((\\alpha-1)\\log k))\\exp(-\\sigma \\log c)(-\\sigma)(\\log c_{t+1} - \\log c) \\\\\n&= RHS_1^* + \\beta \\alpha (\\alpha-1) k^{\\alpha-1} c^{-\\sigma} \\hat{k}_t - \\sigma \\beta(1-\\delta+\\alpha k^{\\alpha-1}) c^{-\\sigma} \\hat{c}_{t+1} \\\\\nLHS_2 &\\approx LHS_2^* + (\\alpha\\exp(\\alpha \\log k) + (1-\\delta)\\exp(\\log k))(\\log k_t - \\log k) \\\\\n&= LHS_2^* + \\left(\\alpha k^{\\alpha-1} + 1 - \\delta\\right) k \\hat{k}_t \\\\\nRHS_2 &\\approx RHS_2^* + \\exp(\\log c)(\\log c_t - \\log c) + \\exp(\\log k)(\\log k_{t+1} - \\log k) \\\\\n&= RHS_2^* + c \\hat{c}_t + k \\hat{k}_{t+1}\n\\end{aligned}\n\\]\nStep 3: 定常状態を引き, 定常状態で割る\n\\[\n\\begin{aligned}\n\\hat{c}_{t+1} &= \\hat{c}_t + \\frac{\\beta \\alpha (\\alpha-1)k^{\\alpha-1}}{\\sigma} \\hat{k}_t \\\\\n\\hat{k}_{t+1} &= -\\frac{c}{k} \\hat{c}_t + \\frac{1}{\\beta} \\hat{k}_t.\n\\end{aligned}\n\\]\nここで, \\(\\frac{1}{\\beta} = 1 - \\delta + \\alpha k^{\\alpha-1}\\) を用いた.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Linearization</span>"
    ]
  },
  {
    "objectID": "11-linearization.html#補論-数値計算例",
    "href": "11-linearization.html#補論-数値計算例",
    "title": "Appendix A — Linearization",
    "section": "A.4 (補論) 数値計算例",
    "text": "A.4 (補論) 数値計算例\n以下のラムゼイモデルのサドルパスを数値計算してみましょう.\n\\[\n\\begin{aligned}\n&c_t^{-\\sigma} = \\beta(1-\\delta+\\alpha k_{t}^{\\alpha-1})c_{t+1}^{-\\sigma} \\\\\n& k_t^\\alpha + (1-\\delta)k_t = c_t + k_{t+1}\n\\end{aligned}\n\\quad\\Rightarrow\\quad\n\\begin{aligned}\n\\hat{c}_{t+1} &= \\hat{c}_t + \\frac{\\beta \\alpha (\\alpha-1)k^{\\alpha-1}}{\\sigma} \\hat{k}_t \\\\\n\\hat{k}_{t+1} &= -\\frac{c}{k} \\hat{c}_t + \\frac{1}{\\beta} \\hat{k}_t.\n\\end{aligned}\n\\]\nパラメータは標準的な値 \\(\\alpha = 0.36, \\beta = 0.96, \\delta = 0.1, \\sigma = 1.5\\) を使います.\n\npars = (α=0.36, β=0.96, δ=0.1, σ=1.5)\n\n(α = 0.36, β = 0.96, δ = 0.1, σ = 1.5)\n\n\n定常状態は以下のように計算できます.\n\\[\n\\begin{aligned}\nc &= k^{\\alpha} - \\delta k \\\\\nk &= \\left(\\frac{1/\\beta - (1-\\delta)}{\\alpha}\\right)^{\\frac{1}{\\alpha-1}}\n\\end{aligned}\n\\]\n\nk_ss(pars) = ((1 / pars.β - (1 - pars.δ)) / pars.α)^(1 / (pars.α - 1))\nc_ss(pars) = k_ss(pars)^pars.α - pars.δ * k_ss(pars)\n\nk_ss(pars), c_ss(pars)\n\n(4.294048197345121, 1.2603826653318553)\n\n\n\nA.4.1 線形モデル\nモデルは以下のように書き換えることができます.\n\\[\n\\begin{pmatrix}\n\\hat{c}_{t+1} \\\\\n\\hat{k}_{t+1}\n\\end{pmatrix}\n=\n\\underbrace{\\begin{pmatrix}\n1 & \\frac{\\beta \\alpha (\\alpha-1) k^{\\alpha-1}}{\\sigma} \\\\\n-\\frac{c}{k} & \\frac{1}{\\beta}\n\\end{pmatrix}}_{M}\n\\begin{pmatrix}\n\\hat{c}_t \\\\\n\\hat{k}_t\n\\end{pmatrix}\n\\]\nここでは, \\(\\hat{k}_0 = 0.01\\) (定常状態から1%の増加) からの変化を考えます. Saddle path 上の \\(\\hat{c}_0\\) を求めるために, 固有値分解を行います.\n\nM = [1 pars.β*pars.α*(pars.α-1)*k_ss(pars)^(pars.α-1)/pars.σ\n    -c_ss(pars)/k_ss(pars) 1/pars.β]\nλ, P = eigen(M)\n\nEigen{Float64, Float64, Matrix{Float64}, Vector{Float64}}\nvalues:\n2-element Vector{Float64}:\n 0.8886746067491774\n 1.1529920599174894\nvectors:\n2×2 Matrix{Float64}:\n -0.462214   0.354629\n -0.886768  -0.935007\n\n\n固有値が1より小さいものが安定な挙動を示すので, 対応した固有ベクトルが saddle path であることがわかります. したがって, \\(\\hat{c}_0\\) は以下のように計算できます.\n\nk̂₀ = 0.01\nĉ₀ = k̂₀ * P[1, 1] / P[2, 1]\n\n0.005212347782677869\n\n\n初期値が分かったため, あとは \\(M\\) を使って順番に \\(\\hat{c}_t, \\hat{k}_t\\) を求めていきます.\n\n\nCode\n# Impulse Response\nT = 25\nĉs = zeros(T)\nk̂s = zeros(T)\nĉs[1] = ĉ₀\nk̂s[1] = k̂₀\nfor t in 2:T\n    ĉs[t], k̂s[t] = M * [ĉs[t-1], k̂s[t-1]]\nend\n\n\n\n\nCode\np1 = plot(1:T, ĉs, label=L\"\\hat{c}_t\", xlabel=L\"t\",\n    ylabel=\"Deviation from Steady State\", title=\"Impulse Response\",\n    yformatter=y -&gt; string(round(y * 100, digits=2), \"%\"))\nplot!(p1, 1:T, k̂s, label=L\"\\hat{k}_t\", linestyle=:dash)\n\n# Phase Diagram\nk̂_min = -0.01\nk̂_max = 0.01\nk̂s_grid = k̂_min:0.0001:k̂_max\nks_grid = k_ss(pars) .* (1 .+ k̂s_grid)\ncs_grid = c_ss(pars) .* (1 .+ k̂s_grid .* P[1, 1] ./ P[2, 1])\n\np2 = vline([k_ss(pars)], label=false, title=\"Phase Diagram\",\n    ylims=(cs_grid[begin], cs_grid[end]))\nannotate!(p2, k_ss(pars) * 1.001, cs_grid[end] * 0.9999,\n    text(L\"\\dot{k} = 0\", :left, 10))\nplot!(p2, ks_grid, k -&gt; k^pars.α - pars.δ * k, label=false)\nannotate!(p2, ks_grid[end] * 0.995,\n    (ks_grid[end]^pars.α - pars.δ * ks_grid[end]) * 0.999,\n    text(L\"\\dot{c}=0\", :left, 10))\nplot!(p2, ks_grid, cs_grid, xlabel=L\"k_t\", ylabel=L\"c_t\", label=false,\n    color=:black, linestyle=:dash)\nscatter!(p2, [k_ss(pars)], [c_ss(pars)], label=false, color=:white)\nannotate!(p2, k_ss(pars) * 0.998, c_ss(pars) * 1.0005, text(L\"SS\", :left, 8))\n\nplot(p1, p2, layout=(1, 2))\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 A.2: Impulse Response and Phase Diagram of the Ramsey Model (Linearized)\n\n\n\n\n\n\nA.4.2 非線形モデル\n非線形モデルは以下のように書き換えることができます. \\[\n\\begin{aligned}\nc_{t+1} &= (\\beta(1-\\delta+\\alpha k_{t}^{\\alpha-1}))^{\\frac{1}{\\sigma}} c_t \\\\\nk_{t+1} &= k_t^\\alpha + (1-\\delta)k_t - c_t \\\\\n\\end{aligned}\n\\]\n線形モデルと異なり, 非線形モデルでは Saddle path の解析解が得られないため, \\(\\hat{k}_0 = 0.01\\) に対応した \\(c_0\\) を数値的に求める必要があります. ここでは十分長い期間 (\\(T = 100\\)) に定常状態に収束すると考えて \\(c_0\\) の値を求める Shooting Method を使います.\n\n\nCode\nF(c_t, k_t; pars) = begin\n    (; α, β, δ, σ) = pars\n    [\n        (β * (1 - δ + α * k_t^(α - 1)))^(1 / σ) * c_t\n        k_t^α + (1 - δ) * k_t - c_t\n    ]\nend\n\nfunction find_c₀(k₀; pars, c₀_min, c₀_max, T=100, tol=1e-7, iter_max=1000)\n\n    k = k_ss(pars)\n    c = c_ss(pars)\n    iter = 0\n    dist = Inf\n    c₀ = (c₀_min + c₀_max) / 2\n    while dist &gt; tol && iter &lt; iter_max\n        c₀ = (c₀_min + c₀_max) / 2\n        c_t, k_t = c₀, k₀\n        for t in 1:T\n            c_t, k_t = F(c_t, k_t; pars)\n            if k_t &lt; 0\n                c₀_max = c₀\n                break\n            end\n        end\n        if k_t &lt; k\n            c₀_max = c₀\n        else\n            c₀_min = c₀\n        end\n        dist = abs(c_t - c)\n        iter += 1\n    end\n\n    if iter == iter_max\n        error(\"Convergence not achieved within the maximum number of iterations.\")\n    end\n\n    return c₀\nend\n\nk₀_left = (1 - 0.01) * k_ss(pars)\nk₀_right = (1 + 0.01) * k_ss(pars)\nc₀_left = find_c₀(k₀_left; pars, c₀_min=(1 - 0.01) * c_ss(pars),\n    c₀_max=(1 + 0.01) * c_ss(pars))\nc₀_right = find_c₀(k₀_right; pars, c₀_min=(1 - 0.01) * c_ss(pars),\n    c₀_max=(1 + 0.01) * c_ss(pars))\n\nfunction compute_nlpath(c₀, k₀; pars, T=100)\n\n    cs = zeros(T)\n    ks = similar(cs)\n    cs[1] = c₀\n    ks[1] = k₀\n    for t in 2:T\n        cs[t], ks[t] = F(cs[t-1], ks[t-1]; pars)\n    end\n    return cs, ks\nend\n\ncs_left, ks_left = compute_nlpath(c₀_left, k₀_left; pars)\ncs_right, ks_right = compute_nlpath(c₀_right, k₀_right; pars)\nĉs_nl = cs_right ./ c_ss(pars) .- 1\nk̂s_nl = ks_right ./ k_ss(pars) .- 1\n\n\n\n\nCode\n# Impulse Response\np1 = plot(1:T, ĉs, label=L\"$\\hat{c}_t$ (Linear)\", xlabel=L\"t\",\n    ylabel=\"Deviation from Steady State\",\n    yformatter=y -&gt; string(round(y * 100, digits=2), \"%\"),\n    title=\"Impulse Response\", color=mypalette[6],\n    linestyle=:dot)\nplot!(p1, 1:T, ĉs_nl[1:T], label=L\"$\\hat{c}_t$ (Nonlinear)\", color=mypalette[6], linestyle=:dash)\nplot!(p1, 1:T, k̂s, label=L\"$\\hat{k}_t$ (Linear)\", color=mypalette[2], linestyle=:dot)\nplot!(p1, 1:T, k̂s_nl[1:T], label=L\"$\\hat{k}_t$ (Nonlinear)\", color=mypalette[2], linestyle=:dash)\n\n# Phase Diagram\nk̂s_grid = k̂_min:0.0001:k̂_max\nks_grid = k_ss(pars) .* (1 .+ k̂s_grid)\ncs_grid = c_ss(pars) .* (1 .+ k̂s_grid .* P[1, 1] ./ P[2, 1])\np2 = plot(ks_grid, cs_grid, xlabel=L\"k_t\", ylabel=L\"c_t\",\n    label=\"Linear\", title=\"Phase Diagram\", color=:black, linestyle=:dash)\nplot!(p2, vcat(ks_left, reverse(ks_right)), vcat(cs_left, reverse(cs_right)),\n    label=\"Nonlinear\", color=:gray, linestyle=:dot)\nvline!(p2, [k_ss(pars)], label=false, color=mypalette[6])\nannotate!(k_ss(pars) * 1.001, cs_grid[end], text(L\"\\dot{k} = 0\", :left, 10))\nplot!(p2, ks_grid, k -&gt; k^pars.α - pars.δ * k, label=false, color=mypalette[2])\nannotate!(p2, ks_grid[end] * 0.995,\n    (ks_grid[end]^pars.α - pars.δ * ks_grid[end]) * 0.999,\n    text(L\"\\dot{c}=0\", :left, 10))\nscatter!(p2, [k_ss(pars)], [c_ss(pars)], label=false, color=:white)\nannotate!(k_ss(pars) * 0.999, c_ss(pars) * 1.0007, text(L\"SS\", :top, 10))\n\nplot(p1, p2, layout=(1, 2))\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 A.3: Impulse Response and Phase Diagram of the Ramsey Model (Nonlinearized)\n\n\n\n\n図 A.3 に示すように, 線形化モデルと非線形モデルのIRFやSaddle Pathはほとんど一致していることがわかります.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Linearization</span>"
    ]
  },
  {
    "objectID": "12-proofs.html",
    "href": "12-proofs.html",
    "title": "Appendix B — Remained Proofs",
    "section": "",
    "text": "B.1 RBC Model",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Remained Proofs</span>"
    ]
  },
  {
    "objectID": "12-proofs.html#new-keynesian-model",
    "href": "12-proofs.html#new-keynesian-model",
    "title": "Appendix B — Remained Proofs",
    "section": "B.2 New Keynesian Model",
    "text": "B.2 New Keynesian Model\n\n命題 B.1 (CES生産関数における価格指数) 最終財の価格 \\(P_t\\) は中間財の価格 \\(P_{j, t}\\) を用いて以下のように表される:\n\\[\nP_t = \\left(\\int_{0}^{1} P_{j, t}^{1-\\varepsilon} \\, dj \\right)^{\\frac{1}{1-\\varepsilon}}.\n\\]\nまた, 各中間財の需要 \\(Y_{j, t}\\) は以下のように表される:\n\\[\nY_{j, t} = \\left(\\frac{P_{j, t}}{P_t}\\right)^{-\\varepsilon} Y_t.\n\\]\n\n\nProof. 最終財の生産者が \\(Y_t\\) 単位の最終財を生産する時の費用最小化問題を考える.\n\\[\n\\min_{\\{Y_{j, t}\\}_{j=0}^{1}} \\int_{0}^{1} P_{j, t} Y_{j, t} \\, dj \\quad \\text{s.t.} \\left(\\int_{0}^{1} Y_{j, t}^{\\frac{\\varepsilon - 1}{\\varepsilon}} \\,dj\\right)^{\\frac{\\varepsilon}{\\varepsilon - 1}} = Y_t.\n\\]\n\\[\n\\mathcal{L} = \\int_{0}^{1} P_{j, t} Y_{j, t} \\, dj + \\lambda_t \\left(Y_t - \\left(\\int_{0}^{1} Y_{j, t}^{\\frac{\\varepsilon - 1}{\\varepsilon}} \\,dj\\right)^{\\frac{\\varepsilon}{\\varepsilon - 1}}\\right)\n\\]\nFOC:\n\\[\n\\begin{aligned}\nP_{j, t} &= \\lambda_t \\underbrace{\\left(\\int_{0}^{1} Y_{j, t}^{\\frac{\\varepsilon-1}{\\varepsilon}} \\, dj \\right)^{\\frac{1}{\\varepsilon - 1}}}_{= Y_{t}^{\\frac{1}{\\varepsilon}}} Y_{j, t}^{-\\frac{1}{\\varepsilon}} \\\\\n&= \\lambda_t \\left(\\frac{Y_{j, t}}{Y_t}\\right)^{-\\frac{1}{\\varepsilon}}.\n\\end{aligned}\n\\tag{B.1}\\]\n両辺に \\(Y_{j, t}\\) を掛けて, \\(j\\) で積分すると\n\\[\n\\int_{j=0}^{1} P_{j, t} Y_{j, t} \\,dj = \\lambda_t Y_t^{\\frac{1}{\\varepsilon}} \\underbrace{\\int_{j=0}^{1} Y_{j, t}^{\\frac{\\varepsilon - 1}{\\varepsilon}} \\,dj}_{=Y_t^{\\frac{\\varepsilon-1}{\\varepsilon}}} = \\lambda_t Y_t\n\\]\nここで \\(\\int_{j=0}^{1} P_{j, t} Y_{j, t} \\,dj = \\lambda_t Y_t\\) という表現を見ると, 左辺は最終財を生産するための費用であることから, \\(\\lambda_t\\) は最終財の価格と解釈できることがわかります.\nここで 式 B.1 の両辺を \\(1-\\varepsilon\\) 乗して, \\(j\\) について積分し, \\(\\frac{1}{1-\\varepsilon}\\) 乗すると\n\\[\n\\begin{aligned}\n\\left(\\int_{0}^{1} P_{j, t}^{1-\\varepsilon} \\,dj\\right)^{\\frac{1}{1-\\varepsilon}} &=\n\\lambda_t Y_t^{\\frac{1}{\\varepsilon}} \\underbrace{\\left(\\int_{0}^{1} Y_{j, t}^{\\frac{\\varepsilon - 1}{\\varepsilon}} \\,dj\\right)^{\\frac{1}{1-\\varepsilon}}}_{Y_t^{-\\frac{1}{\\varepsilon}}} \\\\\n&= \\lambda_t.\n\\end{aligned}\n\\]\nまた, 式 B.1 に \\(\\lambda_t = P_t\\) を代入すると以下を得る.\n\\[\nY_{j, t} = \\left(\\frac{P_{j, t}}{P_t}\\right)^{-\\varepsilon} Y_t.\n\\]\n\n\n命題 B.2 (New Keynesian IS Curveの対数線形化) \\[\nC_t^{-\\sigma} = \\beta \\mathbb{E}_t\\left[\\frac{1+i_t}{1+\\pi_{t+1}}C_{t+1}^{-\\sigma}\\right]\n\\Rightarrow\n\\hat{C}_t = \\mathbb{E}_t[\\hat{C}_{t+1}] - \\frac{1}{\\sigma}\\left(i_t - \\log \\beta - \\mathbb{E}_t[\\pi_{t+1}]\\right).\n\\]\n\n\nProof. 期待値記号を無視して両辺の対数を取ると,\n\\[\n-\\sigma \\log C_t = \\log \\beta + \\log(1+i_t) - \\log(1+\\pi_{t+1}) - \\sigma \\log C_{t+1}.\n\\]\n\\[\n\\begin{aligned}\nLHS &\\approx -\\sigma \\log C - \\sigma \\frac{1}{C} (C_t - C)\n= -\\sigma \\log C - \\sigma \\hat{C}_t \\\\\nRHS &\\approx \\log \\beta + i_t - \\pi_{t+1} - \\sigma \\log C - \\sigma \\frac{1}{C}(C_{t+1} - C) \\\\\n&= \\log \\beta + i_t - \\pi_{t+1} - \\sigma \\log C - \\sigma \\hat{C}_{t+1}.\n\\end{aligned}\n\\]\n\\(LHS = RHS\\) であるので,\n\\[\n\\hat{C}_t = \\mathbb{E}_t[\\hat{C}_{t+1}] - \\frac{1}{\\sigma}\\left(i_t + \\log \\beta - \\mathbb{E}_t[\\pi_{t+1}] \\right).\n\\]\n\n\n命題 B.3 (New Keynesian Phillips Curveの対数線形化) \\[\n(1-MC_{t}^r)\\varepsilon = 1 - \\varphi\\pi_{t}(1+\\pi_{t}) + \\varphi \\beta\\mathbb{E}_t\\left[\n  \\left(\\frac{C_{t+1}}{C_{t}}\\right)^{-\\sigma}\\pi_{t+1}(1+\\pi_{t+1})\\frac{Y_{t+1}}{Y_t}\n\\right]\n\\]\nこれを対数線形化すると,\n\\[\n\\pi_t= \\beta \\mathbb{E}_t\\left[\\pi_{t+1}\\right] + (1-\\beta)\\pi +\n\\frac{\\varepsilon-1 + (1-\\beta)\\varphi\\pi(1+\\pi)}{\\varphi(1+\\pi)(1+2\\pi)}\\widehat{MC^r}_{t} +\n\\frac{\\beta\\pi}{\\varphi(1+2\\pi)}\\mathbb{E}\\left[\\Delta \\hat{Y}_{t+1} - \\sigma \\Delta\\hat{C}_{t+1}\\right]\n\\]\n\n\nProof. NK-ISでは丁寧に導出したので, やや省略します.\n\\[\nLHS = (1-\\exp(\\log MC_{t}^r))\\varepsilon \\approx (1-MC^r)\\varepsilon - \\varepsilon MC^r \\widehat{MC^r}_{t}.\n\\]\n\\(RHS = 1 - RHS_1 + \\varphi\\beta\\mathbb{E}_t\\left[RHS_2\\right]\\) とします.\n\\[\n\\begin{aligned}\nRHS_1 &= \\varphi(\\exp(\\log (1+\\pi_t))-1)\\exp(\\log(1 + \\pi_t)) \\\\\n&\\approx \\varphi\\pi(1+\\pi) + \\varphi ((1+\\pi)^2 + \\pi(1+\\pi))(\\pi_t - \\pi),\\\\\nRHS_2 &= \\exp(-\\sigma\\Delta\\hat{C}_{t+1})(\\exp(\\log (1+\\pi_{t+1}))-1)\\exp(\\log (1+\\pi_{t}))\\exp(\\Delta \\hat{Y}_{t+1}) \\\\\n&\\approx \\pi(1+\\pi) + \\pi(1+\\pi)\\left(-\\sigma\\Delta\\hat{C}_{t+1} + \\Delta \\hat{Y}_{t+1}\\right) + ((1+\\pi)^2 + (1+\\pi)\\pi)(\\pi_{t+1}-\\pi).\n\\end{aligned}\n\\]\n\\(LHS = RHS\\) であり, 定常状態 \\((1-MC^r)\\varepsilon = 1 - (1-\\beta)\\varphi\\pi(1+\\pi)\\) を用いると,\n\\[\n\\begin{aligned}\n-\\varepsilon MC^r \\widehat{MC^r}_{t} &= -\\varphi \\left((1+\\pi)^2 + \\pi(1+\\pi)\\right)(\\pi_t - \\pi) \\\\\n&+\\varphi\\beta\\pi(1+\\pi)\\mathbb{E}_t\\left[-\\sigma \\Delta \\hat{C}_{t+1} + \\Delta \\hat{Y}_{t+1}\\right] \\\\\n&+\\varphi\\beta\\left((1+\\pi)^2 + (1+\\pi)\\pi\\right)\\mathbb{E}_t\\left[\\pi_{t+1} - \\pi\\right].\n\\end{aligned}\n\\]\n全体を \\(\\varphi((1+\\pi)^2 + \\pi(1+\\pi)) = \\varphi(1+\\pi)(1+2\\pi)\\) で割ると,\n\\[\n\\begin{aligned}\n\\pi_{t} - \\pi &= \\beta \\mathbb{E}_t\\left[\\pi_{t+1} - \\pi\\right]\n+\\frac{\\varepsilon MC^r}{\\varphi(1+\\pi)(1+2\\pi)}\\widehat{MC^r}_{t}\n+\\frac{\\beta\\pi}{\\varphi(1 + 2\\pi)}\\mathbb{E}_t\\left[-\\sigma \\Delta \\hat{C}_{t+1} + \\Delta \\hat{Y}_{t+1}\\right] \\\\\n\\pi_t&= \\beta \\mathbb{E}_t\\left[\\pi_{t+1}\\right] + (1-\\beta)\\pi +\n\\frac{\\varepsilon-1 + (1-\\beta)\\varphi\\pi(1+\\pi)}{\\varphi(1+\\pi)(1+2\\pi)}\\widehat{MC^r}_{t} +\n\\frac{\\beta\\pi}{\\varphi(1+2\\pi)}\\mathbb{E}_t\\left[\\Delta \\hat{Y}_{t+1} - \\sigma \\Delta\\hat{C}_{t+1}\\right].\n\\end{aligned}\n\\]\n\n\n補題 B.1 (産出ギャップの対数線形化) 産出ギャップ \\(\\widetilde{Y}_t := \\log Y_t - \\log Y_t^n\\) は, 定常状態のゼロインフレ (\\(\\pi = 0\\)) において, 以下のように線形化される.\n\\[\n\\widetilde{Y}_t = \\hat{Y}_t - \\hat{Y}_t^n.\n\\]\n\n\nProof. ゼロインフレにおいては, 価格改訂のコストの有無は産出に影響を与えないため, sticky price の均衡と flexible price の均衡は等しくなる. したがって, \\(Y = Y^n\\) であるため,\n\\[\n\\begin{aligned}\n\\widetilde{Y}_t &:= \\log Y_t - \\log Y_t^n \\\\\n&= (\\underbrace{\\log Y_t - \\log Y}_{=: \\hat{Y}_t}) - (\\underbrace{\\log Y_t^n - \\log Y^n}_{=: \\hat{Y}_t^n}).\n\\end{aligned}\n\\]\n\n\n補題 B.2 (実質限界費用ギャップと産出ギャップの関係) 実質限界費用ギャップ \\(\\widehat{MC^r}_t\\) と産出ギャップ \\(\\widetilde{Y}_t\\) の関係は以下のように表される.\n\\[\n\\widehat{MC^r}_t = (\\sigma + \\phi) \\widetilde{Y}_t.\n\\]\n\n\nProof. \n\n\\(Y_t = A_t N_t\\) より, \\(N_t = \\frac{Y_t}{A_t}\\)\n式 2.1 より, \\(\\frac{W_t}{P_t} = C_t^{\\sigma}N_t^{\\phi}\\)\n\\(MC^r_t = \\frac{W_t}{A_t P_t}\\)\n\nよって, 以下の式を得ます.\n\\[\nMC^r_t = A_t^{-(\\phi+1)} Y_t^{\\sigma + \\phi}.\n\\]\n対数線形化すると,\n\\[\n\\widehat{MC^r}_t = -(\\phi+1) \\hat{A}_t + (\\sigma + \\phi) \\hat{Y}_t.\n\\]\n式 2.3 より,\n\\[\n\\hat{Y}_t^n = \\frac{1+\\phi}{\\phi+\\sigma}\\hat{A}_t \\Rightarrow\n(1+\\phi)\\hat{A}_t = (\\phi + \\sigma)\\hat{Y}_t^n.\n\\]\nよって, 補題 B.1 を用いて,\n\\[\n\\widehat{MC^r}_t = (\\sigma + \\phi)(\\hat{Y}_t - \\hat{Y}_t^n) = (\\sigma + \\phi) \\widetilde{Y}_t.\n\\]\n\n\n補題 B.3 (IS-MP-PCの行列表現) 式 2.6, 式 2.7, 式 2.8 を整理すると以下を得る.\n\\[\n\\begin{pmatrix}\n\\widetilde{Y}_t \\\\\n\\pi_t\n\\end{pmatrix}\n=\\omega\\underbrace{\\begin{pmatrix}\n\\sigma & 1-\\beta\\phi_{\\pi} \\\\\n\\sigma\\kappa & \\kappa+\\beta(\\sigma+\\phi_y)\n\\end{pmatrix}}_{\\Lambda}\n\\begin{pmatrix}\n\\mathbb{E}_t\\left[\\widetilde{Y}_{t+1}\\right] \\\\\n\\mathbb{E}_t\\left[\\pi_{t+1}\\right]\n\\end{pmatrix}\n+\\omega\\underbrace{\\begin{pmatrix}\n1\\\\\n\\kappa\n\\end{pmatrix}}_{\\mathbf{b}}\n\\left(\\hat{r}_t^n - \\eta_t\\right).\n\\]\nここで, \\(\\omega := (\\sigma + \\phi_y + \\phi_{\\pi}\\kappa)^{-1}\\), \\(\\hat{r}_t^n := r_t^n - r^n\\) である.\n\n\nProof. 式 2.6 を \\(\\sigma\\) 倍し, 式 2.8 を代入すると,\n\\[\n\\sigma\\tilde{Y}_t = \\sigma\\mathbb{E}_t[\\tilde{Y}_{t+1}] - \\phi_{\\pi} \\pi_t - \\phi_y \\tilde{Y}_t - \\eta_t + \\mathbb{E}_t\\left[\\pi_{t+1}\\right] + \\underbrace{r_t^n - r^n}_{=: \\hat{r}_t^n}.\n\\]\n式 2.7 を代入すると,\n\\[\n\\sigma\\tilde{Y}_t = \\sigma\\mathbb{E}_t[\\tilde{Y}_{t+1}] - \\phi_{\\pi} \\kappa\\mathbb{E}_t\\left[\\pi_{t+1}\\right] - \\phi_{\\pi}\\kappa\\tilde{Y}_t - \\phi_y \\tilde{Y}_t - \\eta_t + \\mathbb{E}_t\\left[\\pi_{t+1}\\right].\n\\]\nよって, \\(\\omega := (\\sigma + \\phi_y + \\phi_{\\pi}\\kappa)^{-1}\\) を用いて,\n\\[\n\\widetilde{Y}_t = \\omega\\sigma \\mathbb{E}\\left[\\tilde{Y}_{t+1}\\right] + \\omega(1-\\beta\\phi_{\\pi})\\mathbb{E}_t\\left[\\pi_{t+1}\\right] + \\omega\\left(\\hat{r}_t^n - \\eta_t\\right).\n\\]\nこれを 式 2.7 に代入すると,\n\\[\n\\begin{aligned}\n\\pi_t &= \\beta \\mathbb{E}_t\\left[\\pi_{t+1}\\right] + \\omega \\sigma \\kappa \\mathbb{E}_t\\left[\\tilde{Y}_{t+1}\\right] + \\kappa \\omega (1-\\beta\\phi_{\\pi})\\mathbb{E}_t\\left[\\pi_{t+1}\\right] + \\kappa \\omega \\left(\\hat{r}_t^n - \\eta_t\\right) \\\\\n&= \\omega \\sigma \\kappa \\mathbb{E}_t\\left[\\tilde{Y}_{t+1}\\right] + \\left(\\beta + \\kappa \\omega(1-\\beta\\phi_{\\pi})\\right)\\mathbb{E}_t[\\pi_{t+1}] + \\omega\\kappa\\left(\\hat{r}_t^n - \\eta_t\\right).\n\\end{aligned}\n\\]\nここで, 次の式が成り立つので命題は証明された.\n\\[\n\\begin{aligned}\n\\beta + \\kappa\\omega(1-\\beta\\phi_{\\pi}) &= \\omega\\kappa + \\omega\\beta(\\omega^{-1} - \\phi_{\\pi}\\kappa) \\\\\n&= \\omega\\kappa + \\omega\\beta(\\sigma + \\phi_y).\n\\end{aligned}\n\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Remained Proofs</span>"
    ]
  },
  {
    "objectID": "12-proofs.html#dmp-framework",
    "href": "12-proofs.html#dmp-framework",
    "title": "Appendix B — Remained Proofs",
    "section": "B.3 DMP Framework",
    "text": "B.3 DMP Framework\n\n命題 B.4 (Job Creation Condition) 式 3.4, 式 3.5, 式 3.6, 式 3.7 より, 次の式を得る.\n\\[\n\\frac{\\kappa}{(1-\\gamma)\\lambda_{f}(\\theta_t)} = \\beta \\mathbb{E}\\left[z_{t+1} - b + \\frac{1-\\sigma-\\gamma\\lambda_w(\\theta_{t+1})}{1-\\gamma}\\frac{\\kappa}{\\lambda_{f}(\\theta_{t+1})}\\right].\n\\]\n\n\nProof. ここでは, \\(w(z)\\) を \\(w\\) と省略し, \\(\\mathbb{E}[\\cdot| z]\\) を \\(\\mathbb{E}[\\cdot]\\) と省略します. 式 3.4 に 式 3.5 を代入すると,\n\\[\nJ(z) = z - w + \\beta \\mathbb{E}[(1-\\sigma) J(z')],\n\\tag{B.2}\\] \\[\n\\frac{\\kappa}{\\lambda_f(\\theta)} = \\beta \\mathbb{E}[J(z')].\n\\tag{B.3}\\]\n式 3.6 の差分を取り, \\(1-\\gamma\\) をかけると\n\\[\n(1-\\gamma)(W(z) - U(z)) = (1-\\gamma)(w - b) + \\beta \\mathbb{E}[(1-\\gamma)(1-\\sigma-\\lambda_w(\\theta))(W(z') - U(z'))].\n\\tag{B.4}\\]\n式 B.4 に 式 3.7 と 式 3.5 を代入して,\n\\[\n\\frac{\\gamma}{1-\\gamma} J(z) = w-b + \\beta \\mathbb{E}\\left[\\frac{\\gamma}{1-\\gamma}(1-\\sigma-\\lambda_{w}(\\theta))J(z')\\right].\n\\tag{B.5}\\]\n式 B.2 と 式 B.5 を足して, 式 B.3 を代入すると,\n\\[\n\\begin{aligned}\n\\frac{1}{1-\\gamma} J(z) &=\nz - b + \\beta \\mathbb{E}\\left[\\frac{1-\\sigma-\\gamma\\lambda_w(\\theta)}{1-\\gamma}J(z')\\right]\\\\\n&= z - b + \\frac{1-\\sigma-\\gamma\\lambda_w(\\theta)}{1-\\gamma}\\frac{\\kappa}{\\lambda_f(\\theta)}.\n\\end{aligned}\n\\tag{B.6}\\]\n式 B.6 に \\(\\beta\\) をかけ, \\(t\\) を \\(t+1\\) に置き換えて期待値を取ると,\n\\[\n\\frac{1}{1-\\gamma} \\beta \\mathbb{E}[J(z')] =\n\\beta \\mathbb{E}\\left[z' - b + \\frac{1-\\sigma-\\gamma\\lambda_w(\\theta')}{1-\\gamma}\\frac{\\kappa}{\\lambda_f(\\theta')}\\right].\n\\tag{B.7}\\]\n式 B.7 に 式 B.3 を代入すると, 命題の式を得る.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Remained Proofs</span>"
    ]
  },
  {
    "objectID": "13-foundation.html",
    "href": "13-foundation.html",
    "title": "Appendix C — Foundations",
    "section": "",
    "text": "C.1 AR(1) Process\n平均 \\(0\\) で分散 \\(\\sigma^2\\) (有限) の i.i.d. な確率変数 (\\(\\varepsilon_t\\)) は特にホワイトノイズ (white noise) と言います. 以下の内容は, ホワイトノイズであれば同様に成り立ちますが, 実務上は正規分布 \\(\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2)\\) を仮定することが多いです.\nCode\nx̄ = 0.0\nρ = 0.9\nσ = 0.01\nT = 100\nxs = fill(x̄, T)\nfor t in 2:T\n    xs[t] = x̄ + ρ * xs[t-1] + rand(Normal(0, σ))\nend\n\nplot(1:T, xs, label=false, size=(500, 309))\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 C.1: AR(1) 過程のシミュレーション. \\(\\bar{x} = 0, \\rho = 0.9, \\sigma = 0.01\\).\n証明\n\\[\n\\begin{aligned}\n\\mathbb{E}[x_{t+1}] &= \\mathbb{E}[\\bar{x} + \\rho x_t + \\varepsilon_{t}]= \\bar{x} + \\rho \\mathbb{E}[x_t] + 0\\\\\n\\text{Var}(x_{t+1}) &= \\text{Var}(\\bar{x} + \\rho x_t + \\varepsilon_{t}) = 0 + \\rho^2 \\text{Var}(x_t) + \\sigma^2.\n\\end{aligned}\n\\]\n\\(\\mathbb{E}[x_{t+1}] = \\mathbb{E}[x_t]\\) かつ, \\(\\text{Var}(x_{t+1}) = \\text{Var}(x_t)\\) より, 証明された.\n証明\n\\(k = 1\\) の時,\n\\[\n\\begin{aligned}\n\\text{Cov}(x_{t}, x_{t+1})\n&= \\text{Cov}(x_{t}, \\bar{x} + \\rho x_t + \\varepsilon_{t}) \\\\\n&= \\text{Cov}\\rho(x_{t}, x_t) + \\text{Cov}(x_{t}, \\varepsilon_{t})\\\\\n&= \\rho \\text{Var}(x_t) + 0 \\\\\n&= \\frac{\\rho}{1-\\rho^2}\\sigma^2.\n\\end{aligned}\n\\]\n\\(k = l + 1\\) の時, \\(\\text{Cov}(x_{t}, x_{t+l})= \\frac{\\rho^{l}}{1-\\rho^2}\\sigma^2\\) として,\n\\[\n\\begin{aligned}\n\\text{Cov}(x_{t}, x_{t+l+1})\n&= \\text{Cov}(x_{t}, \\bar{x} + \\rho x_{t+l} + \\varepsilon_{t+l}) \\\\\n&= \\text{Cov}(x_{t}, \\bar{x}) + \\text{Cov}(x_{t}, \\rho x_{t+l}) + \\text{Cov}(x_{t}, \\varepsilon_{t+l}) \\\\\n&= 0 + \\rho \\text{Cov}(x_{t}, x_{t+l}) + 0 \\\\\n&= \\frac{\\rho^{l+1}}{1-\\rho^2}\\sigma^2.\n\\end{aligned}\n\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "13-foundation.html#sec-ar1-process",
    "href": "13-foundation.html#sec-ar1-process",
    "title": "Appendix C — Foundations",
    "section": "",
    "text": "NoteAR(1) 過程\n\n\n\nAR(1) 過程 \\(\\{x_{t}\\}_{t=0}^{\\infty}\\) は以下のように表される.\n\\[\nx_{t+1} = \\bar{x} + \\rho x_t + \\varepsilon_{t}, \\quad \\varepsilon_t \\overset{\\text{iid}}{\\sim} (0, \\sigma^2).\n\\]\n\n\n\n\n\n命題 C.1 (AR(1) 過程の平均と分散) \\[\n\\mathbb{E}[x_t] = \\frac{\\bar{x}}{1-\\rho}, \\quad \\text{Var}(x_t) = \\frac{\\sigma^2}{1-\\rho^2}.\n\\]\n\n\n\n\n\n命題 C.2 (AR(1) 過程の自己共分散 (Autocovariance)) \\[\n\\text{Cov}(x_{t}, x_{t+k}) = \\frac{\\rho^{k}}{1-\\rho^2}\\sigma^2.\n\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "13-foundation.html#labor-supply",
    "href": "13-foundation.html#labor-supply",
    "title": "Appendix C — Foundations",
    "section": "C.2 Labor Supply",
    "text": "C.2 Labor Supply\n\nC.2.1 Static Model\nまずは静学的な労働供給モデルを考えます. 家計は以下の効用最大化問題を解きます:\n\\[\n\\max_{c, h} u(c, h) \\quad \\text{ s.t. } c \\leq w h + I.\n\\tag{C.1}\\]\nここで, 消費 \\(c \\geq 0\\), 労働供給 \\(h \\geq 0\\), 賃金率 \\(w &gt; 0\\), 非労働所得 \\(I \\geq 0\\) です. また, 賃金率 \\(w\\) と非労働所得 \\(I\\) に対する労働供給を \\(h(w, I)\\) とします. この時, 労働供給の弾力性は以下で定義されます:\n\\[\n\\begin{aligned}\n\\eta_{h, w}^M &= \\frac{\\partial h(w, I)}{\\partial w} \\frac{w}{h(w, I)} \\\\\n\\eta_{h, I} &= \\frac{\\partial h(w, I)}{\\partial I} \\frac{I}{h(w, I)}\n\\end{aligned}\n\\]\n特に, 所得を一定とした時の賃金弾力性 \\(\\eta_{h, w}^M\\) をマーシャリアン弾力性 (Marshallian elasticity) と呼びます. 次に, 労働供給の代替効果と所得効果を分離するために, ヒックス弾力性 (Hicksian elasticity) を導入します. 家計は以下の支出最小化問題を解きます:\n\\[\n\\min_{c, h} c - wh \\quad \\text{ s.t. } u(c, h) \\geq \\bar{u}.\n\\]\nここで, 効用水準 \\(\\bar{u}\\) に対する労働供給を \\(h^H(w, \\bar{u})\\) とします. この時, ヒックス弾力性は以下で定義されます:\n\\[\n\\eta_{h, w}^H = \\frac{\\partial h^H(w, \\bar{u})}{\\partial w} \\frac{w}{h^H(w, \\bar{u})}.\n\\]\n\n\n\n\n\n\nNoteスルツキーの恒等式 (Slutsky Equation)\n\n\n\n所得 \\(I\\), 価格ベクトル \\(\\mathbf{p}\\) のもとで次の家計の効用最大化問題を考える.\n\\[\n\\max_{\\mathbf{x}} u(\\mathbf{x}) \\quad \\text{ s.t. } \\mathbf{p}^{\\top} \\mathbf{x} \\leq I.\n\\]\nこの時, 財 \\(i\\) の最適消費を \\(x_i(\\mathbf{p}, I)\\) とする. また, 効用水準 \\(\\bar{u}\\) に対する支出最小化問題を考える.\n\\[\n\\min_{\\mathbf{x}} \\mathbf{p}^{\\top} \\mathbf{x} \\quad \\text{ s.t. } u(\\mathbf{x}) \\geq \\bar{u}.\n\\]\nこの時, 財 \\(i\\) の最適消費を \\(x_i^H(\\mathbf{p}, \\bar{u})\\) とし, 支出関数を \\(I(\\mathbf{p}, \\bar{u})\\) とする. 連鎖律から次の式を得る.\n\\[\n\\frac{\\partial x_i^H(\\mathbf{p}, \\bar{u})}{\\partial p_i} = \\frac{\\partial x_i(\\mathbf{p}, I(\\mathbf{p}, \\bar{u}))}{\\partial p_i} + \\frac{\\partial x_i(\\mathbf{p}, I(\\mathbf{p}, \\bar{u}))}{\\partial I(\\mathbf{p}, \\bar{u})} \\frac{\\partial I(\\mathbf{p}, \\bar{u})}{\\partial p_i}\n\\]\nまた, シェファードの補題 (Shephard’s lemma) \\(\\frac{\\partial I(\\mathbf{p}, \\bar{u})}{\\partial p_i} = x_i^H(\\mathbf{p}, \\bar{u})\\) より,\n\\[\n\\frac{\\partial x_i}{\\partial p_i} = \\frac{\\partial x_i^H(\\mathbf{p}, \\bar{u})}{\\partial p_i} - \\frac{\\partial x_i(\\mathbf{p}, I)}{\\partial I} x_i^H(\\mathbf{p}, \\bar{u}).\n\\]\nこれをスルツキーの恒等式 (Slutsky equation) と呼ぶ.\n\n\n労働供給の問題は価格1の財と価格 \\(-w\\) の労働の2財問題とみなせるため,\n\\[\n\\frac{\\partial h(w, I)}{\\partial w} = \\frac{\\partial h^H(w, \\bar{u})}{\\partial w} + \\frac{\\partial h(w, I)}{\\partial I} h^H(w, \\bar{u}).\n\\]\nここで, 価格が負であるためシェファードの補題が \\(\\frac{\\partial I(w, \\bar{u})}{\\partial w} = -h^H(w, \\bar{u})\\) となることに注意してください. 全体を \\(\\frac{w}{h}\\) で掛けると1,\n\\[\n\\underbrace{\\frac{\\partial h(w, I)}{\\partial w} \\frac{w}{h}}_{\\eta_{h, w}^M} = \\underbrace{\\frac{\\partial h^H(w, \\bar{u})}{\\partial w} \\frac{w}{h}}_{\\eta_{h, w}^H} + \\underbrace{\\frac{\\partial h(w, I)}{\\partial I} \\frac{I}{h}}_{\\eta_{h, I}} \\frac{wh}{I}.\n\\]\nこの式は, 労働供給の弾力性が次の代替効果と所得効果の和に分解されることを示しています.\n\n代替効果: 賃金の増加によって労働のリターンが増加し, 労働供給を増やす効果. 余暇の価格 (労働の機会費用) の増加に対する財への代替と考えてもよい\n所得効果: 所得の増加によって働く必要がなくなり, 労働供給を減らす効果. 余暇が正常財である場合, 所得の増加によって余暇の消費が増加し, 労働供給が減少すると考えてもよい\n\n\n例 C.1 (Cobb-Douglas Utility) \\[\n\\max_{c, l}  (1-\\phi) \\log c + \\phi \\log l \\quad \\text{ s.t. } c \\leq w(1-l) + I.\n\\] \\[\n\\eta_{h, w}^M = \\frac{\\phi}{w}\\frac{I}{h},\n\\]\n\n代替効果: \\(\\eta_{h, w}^H = \\frac{\\phi}{w}\\frac{I}{h} + \\phi\\)\n所得効果: \\(\\eta_{h, I}\\frac{wh}{I}=-\\phi\\)\n\n\\(I = 0\\) の時, 代替効果 \\(\\phi\\) と所得効果 \\(\\phi\\) が打ち消しあい, 労働供給の賃金弾力性は0となる.\n\n\nProof. 最適条件より,\n\\[\nh(w, I) = 1 - \\phi\\left(1 + \\frac{I}{w}\\right).\n\\]\nよって,\n\\[\n\\begin{aligned}\n\\eta_{h, w}^M &= \\frac{\\partial h(w, I)}{\\partial w} \\frac{w}{h(w, I)} = \\frac{\\phi I}{w^2} \\frac{w}{h(w, I)} = \\frac{\\phi}{w}\\frac{I}{h(w, I)}\\\\\n\\eta_{h, I} &= \\frac{\\partial h(w, I)}{\\partial I} \\frac{I}{h(w, I)} = -\\frac{\\phi}{w} \\frac{I}{h(w, I)}.\n\\end{aligned}\n\\]\nスルツキーの恒等式より,\n\\[\n\\eta_{h, w}^H = \\eta_{h, w}^M - \\eta_{h, I} \\frac{wh(w, I)}{I} = \\frac{\\phi}{w}\\frac{I}{h(w, I)} + \\phi.\n\\]\n費用最小化問題\nスルツキーの恒等式を確認するために, ヒックス弾力性を定義から計算する.\n\\[\n\\min_{c, l} c - w(1-l) \\quad \\text{ s.t. } (1-\\phi) \\log c + \\phi \\log l \\geq \\bar{u}.\n\\]\nラグランジアン \\(\\mathcal{L} = c - w(1-l) + \\lambda \\left(\\bar{u} - (1-\\phi) \\log c - \\phi \\log l \\right)\\) の最適条件は次の通り.\n\\[\n\\begin{aligned}\n\\frac{\\partial \\mathcal{L}}{\\partial c} &= 1 - \\lambda \\frac{1-\\phi}{c} = 0, \\\\\n\\frac{\\partial \\mathcal{L}}{\\partial l} &= w - \\lambda \\frac{\\phi}{l} = 0, \\\\\n\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} &= \\bar{u} - (1-\\phi) \\log c - \\phi \\log l = 0.\n\\end{aligned}\n\\]\n一階条件から, \\(c = \\frac{1-\\phi}{\\phi}wl\\) より, 効用制約に代入すると,\n\\[\n\\bar{u} = (1-\\phi) \\log \\left(\\frac{1-\\phi}{\\phi}wl\\right) + \\phi \\log l = (1-\\phi) \\log \\left(\\frac{1-\\phi}{\\phi}w\\right) + \\log l.\n\\]\nよって, 関数 \\(A(\\bar{u}; \\phi)\\) を用いて, \\(l = A(\\bar{u}; \\phi) w^{-(1-\\phi)}\\) と表せるので,\n\\[\nh^H(w, \\bar{u}) = 1 - A(\\bar{u}; \\phi) w^{-(1-\\phi)}.\n\\]\nヒックシアン弾力性は定義から,\n\\[\n\\begin{aligned}\n\\eta_{h, w}^H &= \\frac{\\partial h^H(w, \\bar{u})}{\\partial w} \\frac{w}{h^H(w, \\bar{u})}\\\\\n&= (1-\\phi) A(\\bar{u}; \\phi) w^{-(1-\\phi)-1} \\frac{w}{h^H(w, \\bar{u})} \\\\\n&= (1-\\phi) \\frac{1 - h^H(w, \\bar{u})}{h^H(w, \\bar{u})} & \\because 1 - h^H(w, \\bar{u}) = A(\\bar{u}; \\phi) w^{-(1-\\phi)} \\\\\n\\end{aligned}\n\\]\nここで一階条件から \\(1 - h^H(w, \\bar{u}) = \\frac{\\phi}{1-\\phi}\\frac{c}{w}\\) であり, 均衡における予算制約 \\(c = w h^H(w, \\bar{u}) + I\\) を用いると,\n\\[\n\\begin{aligned}\n\\eta_{h, w}^H &= \\frac{\\phi}{w} \\frac{c}{h^H(w, \\bar{u})} \\\\\n&= \\frac{\\phi}{w} \\frac{w h^H(w, \\bar{u}) + I}{h^H(w, \\bar{u})} \\\\\n&= \\frac{\\phi}{w} \\frac{I}{h^H(w, \\bar{u})} + \\phi.\n\\end{aligned}\n\\]\n\n\n\nC.2.2 Dynamic Model\n次の動学的労働供給モデルを考えます:\n\\[\nV(a) = \\max_{c, h, a'} u(c, h) + \\beta V(a') \\quad \\text{s.t. } c + a' = (1 + r)a + wh.\n\\]\nここで, \\(I := (1+r)a - a'\\) と置くと, 静学的な労働供給モデル (C.1) と同じ形になります. 動学的な労働供給モデルにおける賃金弾力性には, 主に次の3種類があります.\n\nMarshallian 弾力性: 所得を一定とした下での労働供給の弾力性\nHicksian 弾力性: 効用のレベルを一定とした下での労働供給の弾力性\nFrisch 弾力性: 限界効用を一定にした下での労働供給の弾力性\n\nMarshallian & Hicksian Elasticities\nMarshallian 弾力性は, 静学的な労働供給と同様に定義することが可能です. 直感的には, 賃金が下落した際に貯金を切り崩すといった埋め合わせ (compensation) 行動は可能ですが, その点を考慮せずに, 所得 \\(I\\) を一定とした下での労働供給の弾力性として定義されます. その意味でMarshallian 弾力性は uncompesated elasticity とも呼ばれます.\nHicksian 弾力性も静学的な労働供給と同様に定義することが可能です. 賃金が下落した際に貯金を切り崩すことで効用水準を一定に保つ状況を考えるという意味で, Hicksian 弾力性は compensated elasticity とも呼ばれます.\n\n例 C.2 (CRRA Utility) \\[\nu(c, h) = \\frac{c^{1-\\sigma}-1}{1-\\sigma} - \\psi \\frac{h^{1+\\frac{1}{\\gamma}}}{1+\\frac{1}{\\gamma}}.\n\\]\n\\[\n\\eta_{h, w}^M = \\frac{1 - \\sigma(1-s)}{\\frac{1}{\\gamma} + \\sigma(1-s)}.\n\\]\n\n代替効果: \\(\\eta_{h, w}^H = \\frac{1}{\\frac{1}{\\gamma} + \\sigma(1-s)}\\)\n所得効果: \\(\\eta_{h, I}\\frac{wh}{I} = -\\frac{\\sigma - \\sigma s}{\\frac{1}{\\gamma} + \\sigma(1-s)}\\)\n\nここで \\(s = \\frac{I}{c}\\) とおいた.\n\n\nProof. Intra-temporal な最適条件より,\n\\[\nc^{-\\sigma} w = \\psi h^{\\frac{1}{\\gamma}}.\n\\tag{C.2}\\]\n対数をとって, \\(\\log w\\) で微分すると,\n\\[\n-\\sigma \\frac{\\partial \\log c}{\\partial \\log w} + 1 = \\frac{1}{\\gamma} \\frac{\\partial \\log h}{\\partial \\log w}.\n\\tag{C.3}\\]\n予算制約 \\(\\log c = \\log (w h + I)\\) を \\(\\log w\\) で微分すると,\n\\[\n\\begin{aligned}\n\\frac{\\partial \\log c}{\\partial \\log w} &= \\frac{1}{wh + I}\\frac{\\partial (wh+I)}{\\partial w}\\frac{\\partial w}{\\partial \\log w} \\\\\n&= \\frac{wh}{wh + I}\\left(1 + \\frac{\\partial \\log h}{\\partial \\log w}\\right)\\\\\n&= (1 - s) \\left(1 + \\frac{\\partial \\log h}{\\partial \\log w}\\right).\n\\end{aligned}\n\\]\nこれを 式 C.3 に代入すると,\n\\[\n\\eta_{h, w}^M = \\frac{\\partial \\log h}{\\partial \\log w} = \\frac{1 - \\sigma(1-s)}{\\frac{1}{\\gamma} + \\sigma(1-s)}.\n\\]\n式 C.2 の対数を取って, \\(\\log I\\) で微分すると,\n\\[\n-\\sigma \\frac{\\partial \\log c}{\\partial \\log I} = \\frac{1}{\\gamma} \\frac{\\partial \\log h}{\\partial \\log I}.\n\\tag{C.4}\\]\n予算制約 \\(\\log c = \\log (w h + I)\\) を \\(\\log I\\) で微分すると,\n\\[\n\\begin{aligned}\n\\frac{\\partial \\log c}{\\partial \\log I} &= \\frac{1}{wh + I}\\frac{\\partial (wh+I)}{\\partial \\log I} \\\\\n&= \\frac{1}{wh + I}\\left(wh\\frac{\\partial \\log h}{\\partial \\log I} + I\\right)\\\\\n&= \\frac{1}{c}\\left((c-I)\\frac{\\partial \\log h}{\\partial \\log I}+ I\\right) \\\\\n&= (1 - s) \\frac{\\partial \\log h}{\\partial \\log I}+ s.\n\\end{aligned}\n\\]\nこれを 式 C.4 に代入すると,\n\\[\n\\eta_{h, I} = \\frac{\\partial \\log h}{\\partial \\log I} = -\\frac{\\sigma s}{\\frac{1}{\\gamma} + \\sigma(1-s)}.\n\\]\nスルツキーの恒等式より,\n\\[\n\\begin{aligned}\n\\eta_{h, w}^H &= \\eta_{h, w}^M - \\eta_{h, I} \\frac{wh}{I} \\\\\n&= \\frac{1 - \\sigma(1-s)}{\\frac{1}{\\gamma} + \\sigma(1-s)} + \\frac{\\sigma s}{\\frac{1}{\\gamma} + \\sigma(1-s)} \\left(\\frac{1}{s} - 1\\right) \\\\\n&=\\frac{1}{\\frac{1}{\\gamma} + \\sigma(1-s)}.\n\\end{aligned}\n\\]\n\nFrisch Elasticity\nFrisch 弾力性は, 消費の限界効用を一定にした下での労働供給の弾力性として定義されます. また, しばしば lifetime wealth に対する限界効用を一定にした下での労働供給の弾力性としても定義されます. これは恒常所得仮説 (permanent income hypothesis) に基づくと, 消費の限界効用が lifetime wealth のみに依存すると考えるためです.\n直感的には, 一時的な賃金の上昇は lifetime wealth にほとんど影響を与えないため, Frisch 弾力性は一時的な賃金変動に対する労働供給の反応を捉えると考えられます. そのため, RBCモデルなどで確率過程に基づく賃金変動が考慮される場合, Frisch 弾力性が重要な役割を果たします.\n一階条件から, ラグランジュ乗数は \\(\\lambda = u_c(c, h)\\) であり, Frish 弾力性はこの \\(\\lambda\\) を一定にした下での労働供給の弾力性として定義されます. すなわち, \\(u_h(c, h) = -\\lambda w\\) より,\n\\[\nu_{cc} \\frac{\\partial c}{\\partial w} + u_{ch} \\frac{\\partial h}{\\partial w} = 0 \\text{ and }\nu_{hc} \\frac{\\partial c}{\\partial w} + u_{hh} \\frac{\\partial h}{\\partial w} = -\\lambda.\n\\]\nこれを \\(\\frac{\\partial h}{\\partial w}\\) について解くと,\n\\[\n\\frac{\\partial h}{\\partial w} = \\frac{u_{h}}{u_{hh} - \\frac{u_{ch}^2}{u_{cc}}} \\frac{1}{w}.\n\\]\nFrisch 弾力性 \\(\\eta_{h, w}^F := \\frac{\\partial h}{\\partial w}\\frac{w}{h}|_{\\lambda}\\) より,\n\\[\n\\eta_{h, w}^F = \\frac{u_{h}}{h\\left(u_{hh} - \\frac{u_{ch}^2}{u_{cc}}\\right)}.\n\\]\nなお, この式から自明に 例 C.2 において \\(\\eta_{h, w}^F = \\gamma\\) となります. Chetty et al. (2011) はメタ分析を行い, Frisch 弾力性の平均的な推定値を報告しました.\n\nミクロ分析 (擬似実験, quasi-experiment): 0.82\nマクロモデル: 2.84\n\nマクロモデルの結果は, RBCモデルなどで雇用は実質賃金よりも volatile であることを反映しています. この「マクロモデルの Frisch 弾力性はミクロ分析よりもかなり大きい」というPuzzleに関しては今も議論が続いています (e.g., Erosa, Fuster, and Kambourov (2016)).",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "13-foundation.html#root-finding",
    "href": "13-foundation.html#root-finding",
    "title": "Appendix C — Foundations",
    "section": "C.3 Root Finding",
    "text": "C.3 Root Finding\n定常状態の計算や, 一階条件から解を求める際, 数値的に非線形方程式の根を求める必要があります. ここではその基礎である一変数の非線形方程式の根の探索方法を紹介します.\n例えば以下の最適化問題を考えてみましょう.\n\\[\n\\max_{c, l} \\frac{c^{1-\\gamma_c}}{1-\\gamma_c} + \\alpha_l \\frac{l^{1-\\gamma_l}}{1-\\gamma_l} \\quad \\text{s.t.} \\quad c = w (1-l)\n\\tag{C.5}\\]\nこの問題は以下の一階条件の解を求めることで解くことができます.\n\\[\nw^{1-\\gamma_c} (1-l)^{-\\gamma_c} - \\alpha_l l^{-\\gamma_l} = 0.\n\\]\n\nfoc(l; w=1.0, γ_c=1.5, α_l=1.2, γ_l=1.5) =\n    w^(1 - γ_c) * (1 - l)^(-γ_c) - α_l * l^(-γ_l)\n\n\n\nCode\nplot(0.1:0.01:0.9, foc, label=L\"w^{1-\\gamma_c} (1-l)^{-\\gamma_c} - \\alpha_l l^{\\gamma_l}\", lw=2)\nhline!([0.0], ls=:dash, lw=2, label=false)\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 C.2: FOC for CRRA utility\n\n\n\n\nこれは, 一般に解析解がありません (\\(\\gamma_c = \\gamma_l = 1\\)などを除く.) そのため, 数値計算を用いて解く必要があります. この様な一変数の非線形方程式 \\(f(x) = 0\\) の解法として, 以下の2つの選択肢があります.\n\nNon-bracketing method: 初期値 \\(x_0\\) からスタートして, \\(f(x_n)\\) が十分0に近づくまで反復的に計算. (ニュートン法など)\nBracketing method: 区間 \\([a, b]\\) を選び, 区間を狭めていくことで解を求める. (二分法など)\n\n一般に, Non-bracketing method は収束が速い代わりにその収束は保証されません. 一方で, Bracketing method は収束がわずかに遅い代わりに, 解が存在する区間を保証することができます. 以下では, その理由とそれぞれの適した利用場面を解説します.\n\nC.3.1 Non-bracketing Methods\nNon-bracketing method は基本的には一階微分を利用し, 初期値 \\(x_0\\) からスタートして反復的に解を求めます. ここでは, 最も古典的で簡単なニュートン法を紹介します.\n\n\n\n\n\n\nTipニュートン法\n\n\n\n\n初期値 \\(x_0\\) を選ぶ. また停止条件として十分小さい \\(\\epsilon &gt; 0\\) を選ぶ.\n\\(x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}\\) を計算する.\n\\(|f(x_{n+1})| &lt; \\epsilon\\) ならば停止し, \\(x_{n+1}\\) を解として返す. そうでなければ, \\(n \\leftarrow n+1\\) として2に戻る.\n\n\n\n\n\n\n\n\n\n図 C.3: Visualization of Newton Method\n\n\n\n\ndfoc(l; w=1.0, γ_c=1.5, α_l=1.2, γ_l=1.5) =\n    w^(1 - γ_c) * γ_c * (1 - l)^(-γ_c - 1) + α_l * γ_l * l^(-γ_l - 1)\n\nfind_zero((foc, dfoc), 0.5, Roots.Newton())\n\n0.530349570343484\n\n\nHybrid method\nJuliaのRoots.jlのデフォルトのNon-bracketing method (Order0())は, 厳密にはBracketing methodも一部利用します. また一階微分も必要としないため, より汎用的に利用することができます. ただし, 収束が速く収束が保証されない性質はNon-bracketing methodと同じです.\n\nl = find_zero(foc, 0.5)\n\n0.530349570343484\n\n\n定義域の変換\nNon-bracketing method では, \\(x_{n+1}\\) の値を更新する際に, 必ずしも \\(x_{n+1}\\) が定義域内にあることが保証されません. 例えば, 今回の例では 余暇時間ですので, \\(l \\in (0, 1)\\) ですが, 初期値や関数形によっては, \\(l &lt; 0\\) や \\(l &gt; 1\\) となる可能性があります.\nこの場合, 端点解が存在するかどうかを確認する必要があります. 端点解が想定される場合は, 次節で説明するように Bracketing method を利用することが適しています. 今回の例では, 端点解が存在しないため (\\(l = 0, 1\\) のどちらにおいても効用が負の無限大に発散するため), Non-bracketing method での解の収束が保証されています. 以下の様な定義域の変換を用いることで, 解の収束を保証することができます.\n\n\n\n\n\n\nNote定義域の変換\n\n\n\n\\(x\\) が区間 \\((a, b)\\) で定義されるとき, 以下の変換を用いて定義域を \\((-\\infty, \\infty)\\) にすることができる.\n\\[\nx = \\frac{a + b \\exp y}{1 + \\exp y}\n\\]\n明らかに, \\(y \\rightarrow -\\infty\\) のとき \\(x \\rightarrow a\\), \\(y \\rightarrow \\infty\\) のとき \\(x \\rightarrow b\\) となる.\n\n\n今回の例では, \\(l = \\frac{1}{1 + \\exp(y)}\\) (つまりシグモイド関数) という変換を用いることができます.\n\ny = find_zero(y -&gt; foc(1 / (1 + exp(y))), 0.0)\nl = 1 / (1 + exp(y))\n\n0.530349570343484\n\n\n\n\nC.3.2 Bracketing Methods\nBracketing method は, 解が存在する区間 \\([a, b]\\) を選び, その区間を狭めていくことで解を求めます. ここでは最も基本的な二分法を用いることで解を求めることができます.\n\n\n\n\n\n\nTip二分法\n\n\n\n\n区間 \\([a, b]\\) を選ぶ. また停止条件として十分小さい \\(\\epsilon &gt; 0\\) を選ぶ.\n\\(f(a) \\cdot f(b) &lt; 0\\) ならば, \\(c = \\frac{a + b}{2}\\) を計算する.\n\\(|f(c)| &lt; \\epsilon\\) ならば, \\(c\\) を解として返す. そうでなければ, \\(f(a) \\cdot f(c) &lt; 0\\) ならば, \\(b \\leftarrow c\\) として2に戻る. そうでなければ, \\(a \\leftarrow c\\) として2に戻る.\n\n\n\n\n\n\n\n\n\n図 C.4: Visualization of Bisection Method\n\n\n\n例えば, 今回の例では \\(l \\in (0, 1)\\) ですので, \\(l = 0\\) と \\(l = 1\\) で効用が発散することから, 解が存在する区間は \\((0, 1)\\) です. なお, 端点でFOCが定義されてない場合も多いので, 端点より微小に内側の区間を選ぶことが多いです.\n\nϵ = 1e-9\nl = find_zero(foc, (ϵ, 1 - ϵ))\n\n0.530349570343484\n\n\n端点解の存在\n以下の様なカップルの意思決定問題を考えてみましょう.\n\\[\n\\max_{c_m, c_f, l_m, l_f} u(c_m, l_m) + u(c_f, l_f)\n\\tag{C.6}\\]\nsubject to\n\\[\nc_m + c_f = w_m (1 - l_m) + w_f (1 - l_f).\n\\]\n一階条件から以下の関係が導けます:\n\\[\n\\frac{l_m}{l_f} = \\left(\\frac{w_f}{w_m}\\right)^{\\frac{1}{\\gamma_l}}.\n\\]\nこの関係から一方の相対賃金が十分に大きい場合, 例えば \\(w_m \\gg w_f\\) の場合, \\(l_f &gt; 1\\) となる可能性があります (\\(l_m\\) は余暇時間のため, 0よりある程度大きい値をとるということが想像できます.) 内点解が存在する場合の \\(l_f\\) に関する一階条件は以下のようになります.\n\\[\nw_m\\left(1-\\left(\\frac{w_f}{w_m}\\right)^{\\frac{1}{\\gamma_l}}l_f\\right) + w_f(1-l_f) - 2\\left(\\frac{w_f}{\\alpha_l}\\right)^{\\frac{1}{\\gamma_c}}l_f^{\\frac{\\gamma_l}{\\gamma_c}} = 0.\n\\]\n\n\nCode\nfunction foc_bargaining(l_f; w_m=1.0, w_f=0.5, γ_c=1.5, α_l=1.2, γ_l=1.5)\n    return w_m * (1 - (w_f / w_m)^(1 / γ_l) * l_f) + w_f * (1 - l_f) -\n           2 * (w_f / α_l)^(1 / γ_c) * l_f^(γ_l / γ_c)\nend\n\nlf_grid = 0.01:0.01:0.99\nplot(lf_grid, l_f -&gt; foc_bargaining(l_f, w_f=1.0), label=L\"w_f = 1.0\", xlabel=L\"l_f\")\nplot!(lf_grid, l_f -&gt; foc_bargaining(l_f, w_f=0.5), label=L\"w_f = 0.5\", linestyle=:dash)\nplot!(lf_grid, l_f -&gt; foc_bargaining(l_f, w_f=0.1), label=L\"w_f = 0.1\", linestyle=:dot)\nhline!([0.0], lw=2, label=false, color=:black)\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 C.5: FOC for bargaining problem. \\(w_m = 1.0\\), \\(\\alpha_l = 1.2\\), \\(\\gamma_c = \\gamma_l = 1.5\\).\n\n\n\n\nまた, \\(l_f = 1\\) における一階条件は以下のようになります.\n\\[\nw_m(1-l_m) - 2\\left(\\frac{w_m}{\\alpha_l}\\right)^{\\frac{1}{\\gamma_c}} l_m^{\\frac{\\gamma_l}{\\gamma_c}} = 0.\n\\]\nこの様な場合, Bracketing method の考えが有効です.\n\n端点 \\(l_m = 0, 1\\) (実用上は \\(\\epsilon, 1-\\epsilon\\)) において, 一階条件の値を計算.\n一階条件の値が異符号であれば, 二分法を用いて解を求める.\n一階条件の値が同符号であれば, 端点解 (この場合, \\(l_f = 1\\)) 上の解を求める.\n\n\nfunction solve_bargaining(; w_m=1.0, w_f=0.5, γ_c=1.5, α_l=1.2, γ_l=1.5)\n\n    ϵ = 1e-9\n    left = w_m * (1 - (w_f / w_m)^(1 / γ_l) * ϵ) + w_f * (1 - ϵ) -\n           2 * (w_f / α_l)^(1 / γ_c) * ϵ^(γ_l / γ_c)\n    right = w_m * (1 - (w_f / w_m)^(1 / γ_l) * (1 - ϵ)) + w_f * ϵ -\n            2 * (w_f / α_l)^(1 / γ_c) * (1 - ϵ)^(γ_l / γ_c)\n\n    if left * right &lt; 0\n        l_f = find_zero(\n            l_f -&gt; w_m * (1 - (w_f / w_m)^(1 / γ_l) * l_f) + w_f * (1 - l_f) -\n                   2 * (w_f / α_l)^(1 / γ_c) * l_f^(γ_l / γ_c),\n            (ϵ, 1 - ϵ))\n        l_m = (w_f / w_m)^(1 / γ_l) * l_f\n    else\n        l_f = 1.0\n        x = find_zero(\n            x -&gt; w_m * (1 - 1 / (1 + exp(x))) -\n                 2 * (w_m / α_l)^(1 / γ_c) * (1 / (1 + exp(x)))^(γ_l / γ_c),\n            0.0)\n        l_m = 1 / (1 + exp(x))\n    end\n\n    c = w_m * (1 - l_m) + w_f * (1 - l_f)\n    c_m = 0.5 * c\n    c_f = 0.5 * c\n    U = (c_m^(1 - γ_c) / (1 - γ_c)) + α_l * (l_m^(1 - γ_l) / (1 - γ_l)) +\n        (c_f^(1 - γ_c) / (1 - γ_c)) + α_l * (l_f^(1 - γ_l) / (1 - γ_l))\n    return (c_m=c_m, c_f=c_f, l_m=l_m, l_f=l_f, U=U)\nend\n\n\n\nCode\nplot(0.1:0.01:0.9, w_f -&gt; solve_bargaining(w_f=w_f).l_m, label=L\"l_m\", xlabel=L\"w_f\")\nplot!(0.1:0.01:0.9, w_f -&gt; solve_bargaining(w_f=w_f).l_f, label=L\"l_f\", linestyle=:dash)\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 C.6: Solution of bargaining problem. \\(w_m = 1.0, \\alpha_l = 1.2, \\gamma_c = \\gamma_l = 1.5\\).\n\n\n\n\n\n\n\n\n\n\nChetty, Raj, Adam Guren, Day Manoli, and Andrea Weber. 2011. “Are Micro and Macro Labor Supply Elasticities Consistent? A Review of Evidence on the Intensive and Extensive Margins.” American Economic Review 101 (3): 471–75. https://doi.org/10.1257/aer.101.3.471.\n\n\nErosa, Andrés, Luisa Fuster, and Gueorgui Kambourov. 2016. “Towards a Micro-Founded Theory of Aggregate Labour Supply.” The Review of Economic Studies 83 (3): 1001–39. https://doi.org/10.1093/restud/rdw010.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "13-foundation.html#footnotes",
    "href": "13-foundation.html#footnotes",
    "title": "Appendix C — Foundations",
    "section": "",
    "text": "均衡において \\(h(w, I) = h^H(w, \\overline{u})\\) であるため, 右辺の \\(h(w, I)\\) を \\(h^H(w, \\overline{u})\\) に置き換えても問題ありません.↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "14-dp.html",
    "href": "14-dp.html",
    "title": "Appendix D — Dynamic Programming",
    "section": "",
    "text": "D.1 Introduction\nこの章では, 動的計画法 (Dynamic Programming) による非線形モデルの数値解法について学びます.　次のベルマン方程式を解くことを考えます.\n\\[\nV(k, z) = \\max_{k'} U\\left(zf(k) + (1-\\delta)k - k'\\right) + \\beta \\mathbb{E}[V(k', z') | z].\n\\]\nsubject to\n\\[\nc + k' = zf(k) + (1-\\delta)k.\n\\]\nここで, モデルを「解く」とは, 価値関数 \\(V(k, z)\\) や政策関数 \\(c = g_c(k, z)\\), \\(k' = g_k(k, z)\\), を数値的に求めることを意味します. つまり, 次のステップを踏みます.\nいきなり確率過程を考えるのは難しいので, まずは確定的な場合から始めます.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Dynamic Programming</span>"
    ]
  },
  {
    "objectID": "14-dp.html#introduction",
    "href": "14-dp.html#introduction",
    "title": "Appendix D — Dynamic Programming",
    "section": "",
    "text": "グリッドの離散化: \\(k = k_1, k_2, \\dots, k_I\\), \\(z = z_1, z_2, \\dots, z_J\\)\n価値関数の計算: 各 \\((k_i, z_j)\\) に対して \\(V(k_i, z_j)\\) を計算\n政策関数の計算: 各 \\((k_i, z_j)\\) に対して \\(c = g_c(k_i, z_j)\\) , \\(k' = g_k(k_i, z_j)\\), を計算",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Dynamic Programming</span>"
    ]
  },
  {
    "objectID": "14-dp.html#deterministic-case",
    "href": "14-dp.html#deterministic-case",
    "title": "Appendix D — Dynamic Programming",
    "section": "D.2 Deterministic Case",
    "text": "D.2 Deterministic Case\n確定的な場合の次のベルマン方程式を考えます.\n\\[\nV(k) = \\max_{k'} \\left\\{u(f(k) + (1-\\delta)k - k') + \\beta V(k')\\right\\}.\n\\]\nこの問題を数値的に解く方法には, 大きく分けて2つの方法があります.\n\nValue Function Iteration\n\nベルマン方程式の不動点を直接求める方法\n収束性が保証されているが, 収束速度は比較的遅い\n\nPolicy Function Iteration\n\nオイラー方程式の不動点を求める方法\n収束性は保証されていないが, 収束速度は比較的速い\n\n\n数値計算に用いるために, 以下の関数形とパラメータを仮定します.\n\n\\(u(c) = \\log c\\)\n\\(f(k) = k^\\alpha\\)\n\\(\\beta = 0.96\\)\n\\(\\delta = 0.1\\)\n\\(\\alpha = 0.36\\)\n\n\n\nCode\n@kwdef struct DeterministicModel{TF&lt;:AbstractFloat,TI&lt;:Integer}\n    # Parameters\n    α::TF = 0.36\n    β::TF = 0.96\n    δ::TF = 0.1\n\n    # Value Function\n    n_k::TI = 101\n    k_min::TF = 0.5\n    k_max::TF = 10.0\n    k_grid::Vector{TF} = collect(range(k_min, k_max, length=n_k))\n    V::Vector{TF} = zeros(n_k)\n    gc::Vector{TF} = zeros(n_k)\n    gk::Vector{TF} = zeros(n_k)\nend\n\nu(c) = log(max(c, 1e-9)) # consumption cannot be negative\nu′(c) = 1 / c\nf(k; m::DeterministicModel) = k^m.α\nf′(k; m::DeterministicModel) = m.α * k^(m.α - 1)\n\n\n\nD.2.1 Value Function Iteration\n\n\n\n\n\n\nNoteValue Function Iteration\n\n\n\n\n\\(k\\) の定義域を \\([k_{\\min}, k_{\\max}]\\) を \\(n\\) 個のグリッドポイントに分割する.\n\\(V(k)\\) の初期値 \\(V^0\\) を適当に設定する. つまり, \\(V^0 = (V_0^0, V_1^0, \\dots, V_n^0)\\) に適当な値を設定する.\n\\(V^0\\) をベルマン方程式の右辺に代入し, 各 \\(k_i\\) に対して \\(V_i^1\\) を計算する.\n\n\\(k_i\\) に対する最適な \\(k'\\) を求めるために, グリッドポイント全てを試し, 最大化を行う.\n\n2-3を繰り返す. 収束条件は以下のように設定する.\n\n\\(|V^N - V^{N-1}| &lt; \\varepsilon\\)\n\\(|V^N - V^{N-1}|\\) はベクトルのノルム\n\\(\\varepsilon\\) は十分小さな値を設定する. 例えば, \\(\\epsilon = 10^{-6}\\) とする\n\n\n\n\nこのアルゴリズムは, 縮小写像定理 (Contraction Mapping Theorem) に基づいており, 収束が保証されています. 詳しくは Stokey, Lucas, and Prescott (1989) の第3章を参照してください. また, このような収束の閾値 \\(\\varepsilon\\) を tolerance と呼ぶことがあります.\n\n\nCode\nfunction vfi!(m::DeterministicModel; tol=1e-6, max_iter=1000, verbose=true)\n    (; k_grid, β, δ) = m\n\n    iter, dist = 0, Inf\n    V_new = similar(m.V)\n    gk_new = similar(m.gk)\n    gc_new = similar(m.gc)\n    while dist &gt; tol && iter &lt; max_iter\n        for (i_k, k) in enumerate(k_grid)\n            val_opt = -Inf\n            i_k′_opt = 0\n            for (i_k′, k′) in enumerate(k_grid)\n                val = u(f(k; m) + (1 - δ) * k - k′) + β * m.V[i_k′]\n                if val &gt; val_opt\n                    val_opt = val\n                    i_k′_opt = i_k′\n                end\n            end\n            V_new[i_k] = val_opt\n            gk_new[i_k] = k_grid[i_k′_opt]\n            gc_new[i_k] = f(k; m) + (1 - δ) * k - gk_new[i_k]\n        end\n\n        dist = maximum(abs, V_new - m.V)\n        m.V .= V_new\n        m.gk .= gk_new\n        m.gc .= gc_new\n        iter += 1\n    end\n\n    if verbose\n        if iter == max_iter\n            println(\"Warning: Maximum iterations reached.\")\n        else\n            println(\"Converged in $iter iterations.\")\n        end\n    end\n\n    return nothing\nend\n\nm = DeterministicModel()\nvfi!(m)\n\n\n\n\nCode\nplot(m.k_grid, m.V, label=false, xlabel=L\"Capital $k$\", ylabel=L\"Value $V(k)$\")\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 D.1: Value Function Computed by Value Function Iteration (VFI).\n\n\n\n\nなお, 各イタレーションでは, \\(k\\) に対する最適な \\(k'\\) や \\(c\\) を求めています. それらを記録しておくことで, 政策関数 \\(c = g_c(k)\\) や \\(k' = g_k(k)\\) を求めることができます.\n\n\nCode\np1 = plot(m.k_grid, m.gc, label=false, xlabel=L\"Capital $k$\", ylabel=L\"Consumption $c$\")\np2 = plot(m.k_grid, m.gk, label=false, xlabel=L\"Capital $k$\", ylabel=L\"Next Capital $k'$\")\nplot(p1, p2, layout=(1, 2))\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 D.2: Policy Function Computed by Value Function Iteration (VFI).\n\n\n\n\nこれを見ると, 政策関数の計算精度がやや低いことがわかります. グリッドポイントを増やす, 補完を用いるなどの工夫で対処できますが, より高速で高精度な方法として, 次に紹介する Policy Function Iteration を用いる方法があります.\n\n\nD.2.2 Policy Function Iteration\n上記のベルマン方程式から, 以下のオイラー方程式が導出されます.\n\\[\nu'(c) = \\beta u'(c')\\left(f'(k') + (1-\\delta)\\right).\n\\]\nここで, 政策関数 \\(c' = g_c(k')\\) と予算制約 \\(k' = f(k) + (1-\\delta)k - c\\) を導入すると, 上記のオイラー方程式は以下のように書き換えられます.\n\\[\nu'(c) = \\beta u'(g_c(f(k) + (1-\\delta)k - c))\\left(f'(f(k) + (1-\\delta)k - c) + (1-\\delta)\\right).\n\\]\nこの時, \\(g_c^{0}(k)\\) を所与とした時に \\(c\\) について解くと新しい政策関数 \\(g_c^{1}(k)\\) が得られます. この政策関数繰り返し更新することで, 政策関数の不動点を求めることができます.\n\n\n\n\n\n\nNotePolicy Function Iteration\n\n\n\n\n\\(k\\) の定義域を \\([k_{\\min}, k_{\\max}]\\) を \\(n\\) 個のグリッドポイントに分割する\n\\(g_c(k)\\) の初期値 \\(g_c^0\\) を適当に設定する. つまり, \\(g_c^0 = (g_{c,0}^0, g_{c,1}^0, \\dots, g_{c,n}^0)\\) に適当な値を設定する.\n\\(g_c^0\\) をオイラー方程式の右辺に代入し, 各 \\(k_i\\) に対して \\(g_{c,i}^1\\) を計算する.\n2-3を繰り返す. 収束条件は以下のように設定する.\n\n\\(|g_c^N - g_c^{N-1}| &lt; \\varepsilon\\)\n\n\\(|g_c^N - g_c^{N-1}|\\) はベクトルのノルム\n\\(\\varepsilon\\) は十分小さな値を設定する. 例えば, \\(\\epsilon = 10^{-6}\\) とする\n\n\n\n\nまた, ここから \\(k' := g_k(k) = f(k) + (1-\\delta)k - g_c(k)\\) が求められます.\n\nfunction euler_eq(c, k, gc_interp; m::DeterministicModel)\n    (; β, δ, k_grid) = m\n\n    k′ = max(f(k; m) + (1 - δ) * k - c, k_grid[begin])\n    c′ = gc_interp(k′)\n\n    return u′(c) - β * u′(c′) * (f′(k′; m) + 1 - δ)\nend\n\nfunction pfi!(m::DeterministicModel; tol=1e-6, max_iter=1000, verbose=true)\n    (; k_min, k_max, k_grid, α, β, δ) = m\n\n    gc_new = similar(m.gc)\n    iter, dist = 0, Inf\n    while dist &gt; tol && iter &lt; max_iter\n\n        gc_interp = linear_interpolation(k_grid, m.gc)\n\n        for (i_k, k) in enumerate(k_grid)\n            c_min = max(1e-9, f(k; m) + (1 - δ) * k - k_grid[end])\n            c_max = f(k; m) + (1 - δ) * k - k_grid[begin]\n            ee_left = euler_eq(c_min, k, gc_interp; m)\n            ee_right = euler_eq(c_max, k, gc_interp; m)\n            if ee_left &gt; 0 && ee_right &gt; 0\n                gc_new[i_k] = c_max\n            elseif ee_left &lt; 0 && ee_right &lt; 0\n                gc_new[i_k] = c_min\n            else\n                gc_new[i_k] = find_zero(c -&gt; euler_eq(c, k, gc_interp; m), (c_min, c_max))\n            end\n        end\n\n        dist = maximum(abs, gc_new .- m.gc)\n        m.gc .= gc_new\n        iter += 1\n    end\n\n    m.gk .= f.(k_grid; m) .+ (1 .- δ) .* k_grid .- m.gc\n    if verbose\n        if iter == max_iter\n            println(\"Warning: Maximum iterations reached.\")\n        else\n            println(\"Converged in $iter iterations.\")\n        end\n    end\n\n    return nothing\nend\n\nm = DeterministicModel()\npfi!(m)\n\nConverged in 80 iterations.\n\n\n\n\nCode\np1 = plot(m.k_grid, m.gc, label=false, xlabel=L\"Capital $k$\", ylabel=L\"Consumption $c$\")\np2 = plot(m.k_grid, m.gk, label=false, xlabel=L\"Capital $k$\", ylabel=L\"Next Capital $k'$\")\nplot(p1, p2, layout=(1, 2))\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 D.3: Policy Function Computed by Policy Function Iteration (PFI).\n\n\n\n\nさらに, \\(g_c(k), g_k(k)\\) から価値関数 \\(V(k)\\) を求める方法は主に2つあります.\n\n\\(V(k) \\leftarrow u(g_c(k)) + \\beta V(g_k(k))\\) を用いて \\(V(k)\\) の不動点を求める方法 (VFI)\n線形方程式\n\n離散化された \\(k\\) から \\(k'\\) への遷移行列 \\(P\\) を求める. グリッド \\(k_i\\) が \\(k_j\\) と \\(k_{j+1}\\) の間に遷移する場合, 以下のように定義します.\n\n\\(P_{i, j} = \\frac{k_{j+1} - g_k(k_i)}{k_{j+1} - k_j}\\)\n\\(P_{i, j+1} = \\frac{g_k(k_i) - k_j}{k_{j+1} - k_j}\\)\n\\(P_{i, k} = 0\\), \\(k \\neq j, j+1\\)\n\n\\(u, V\\) を \\(u(g_c(k)), V(k)\\) からなる離散化されたベクトルとすると, \\(V = u + \\beta P V\\) となる\n\\(V = (I - \\beta P)^{-1} u\\) により \\(V\\) を求めることができる\n\n\nここでは, より高速な線型方程式を用いる方法を実装します. より速度を求める場合, 遷移行列はほとんどの要素がゼロであるため, 疎行列 (Sparse Matrix) を用いることで高速化する可能性があります. Juliaの場合, SparseArrays.jl で実装されています.\n\nfunction compute_vf!(m::DeterministicModel)\n    (; n_k, k_grid, gc, gk, β, δ) = m\n    P = zeros(n_k, n_k)\n    for (i_k, k) in enumerate(k_grid)\n        k′ = gk[i_k]\n        j = searchsortedlast(k_grid, k′)\n        if j == 0\n            P[i_k, 1] = 1.0\n        elseif j == n_k\n            P[i_k, n_k] = 1.0\n        else\n            P[i_k, j] = (k_grid[j+1] - k′) / (k_grid[j+1] - k_grid[j])\n            P[i_k, j+1] = (k′ - k_grid[j]) / (k_grid[j+1] - k_grid[j])\n        end\n    end\n\n    m.V .= (I - β * P) \\ (u.(gc))\n\n    return nothing\nend\n\ncompute_vf!(m)\nplot(m.k_grid, m.V, label=false, xlabel=L\"Capital $k$\", ylabel=L\"Value $V(k)$\")\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 D.4: Value Function from PFI and Linear Equation\n\n\n\n\nまた, VFIよりもPFIの方が実行速度が速いことも確認できます.\n\n@benchmark vfi!(m, verbose=false) setup = (m = DeterministicModel())\n\n\nBenchmarkTools.Trial: 75 samples with 1 evaluation per sample.\n Range (min … max):  66.517 ms …  68.777 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     66.838 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   67.113 ms ± 513.610 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n       ▂ █ ▄ ▂                                                  \n  ▃▁▆▁▆███▆█▅█▁▃▃▁▁▁▁▁▁▅▃▅▁▃▁▅▃▃▅▁▁▁▃▃▃▁▅▅▁▃▃▁▃▁▃▃▁▃▃▁▁▁▁▁▁▁▁▃ ▁\n  66.5 ms         Histogram: frequency by time         68.4 ms &lt;\n\n Memory estimate: 265.53 KiB, allocs estimate: 586.\n\n\n\n\n@benchmark (pfi!(m, verbose=false); compute_vf!(m)) setup = (m = DeterministicModel())\n\n\nBenchmarkTools.Trial: 139 samples with 1 evaluation per sample.\n Range (min … max):  35.260 ms … 84.873 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     35.533 ms              ┊ GC (median):    0.00%\n Time  (mean ± σ):   36.189 ms ±  4.248 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n   █▄▆                                                         \n  ▆████▇▆▆▅▄▄▃▄▁▁▁▁▃▃▃▁▁▁▁▁▁▁▁▃▁▁▁▁▁▁▁▁▁▃▁▁▃▁▁▃▁▃▃▁▁▁▁▃▃▁▁▃▁▃ ▃\n  35.3 ms         Histogram: frequency by time        39.4 ms &lt;\n\n Memory estimate: 468.94 KiB, allocs estimate: 340.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Dynamic Programming</span>"
    ]
  },
  {
    "objectID": "14-dp.html#stochastic-case",
    "href": "14-dp.html#stochastic-case",
    "title": "Appendix D — Dynamic Programming",
    "section": "D.3 Stochastic Case",
    "text": "D.3 Stochastic Case\n\\(V(k, z)\\) の数値計算するためには, \\(z\\) の状態空間も離散化する必要があります. この時, 同時に確率過程 (AR(1) process) も離散化, つまりマルコフ過程として近似する必要があります. ここで, \\(z = z_1, \\dots, z_J\\) に離散化し, 各状態間の遷移確率を \\(J \\times J\\) 行列の \\(\\Lambda\\) とします. すると, ベルマン方程式は以下のようになります.\n\\[\nV(k, z) = \\max_{k'} \\left\\{u(f(k, z) + (1-\\delta)k - k') + \\beta \\sum_{z'} \\Lambda(z, z') V(k', z')\\right\\}.\n\\]\nこれはただ足し算の回数が増えただけで, 基本的には確定的な場合と同じです. AR(1) プロセスを離散化する方法として, ここでは Tauchen Method (Tauchen 1986) を用います.\n\nD.3.1 Tauchen Method\n実数列 \\(x_t\\) が以下のAR(1)過程に従うとします.\n\\[\nx_{t+1} = (1 - \\rho) \\mu + \\rho x_t + \\sigma \\varepsilon_{t+1}, \\quad \\varepsilon_{t+1} \\sim \\mathcal{N}(0, 1).\n\\]\nこれを \\(n\\) 個のグリッドポイント \\(\\{x_1, \\dots, x_n\\}\\) におけるマルコフ過程として離散化することを考えます. すなわち, 以下のような遷移確率行列 \\(\\Lambda\\) を考えます.\n\\[\n\\begin{pmatrix}\nx_{1, t+1} \\\\\n\\vdots \\\\\nx_{n, t+1}\n\\end{pmatrix} =\n\\begin{pmatrix}\n\\lambda_{1, 1} & \\cdots & \\lambda_{1, n} \\\\\n\\vdots & \\ddots & \\vdots \\\\\n\\lambda_{n, 1} & \\cdots & \\lambda_{n, n}\n\\end{pmatrix}\n\\begin{pmatrix}\nx_{1, t} \\\\\n\\vdots \\\\\nx_{n, t}\n\\end{pmatrix}\n\\]\nここで, \\(\\lambda_{i, j} = \\Pr(x_{t+1} = x_j \\mid x_t = x_i)\\) であり, \\(\\sum_{j=1}^{n} \\lambda_{i, j} = 1\\) が成り立ちます. この遷移確率行列を求める方法として, Tauchen Method が知られています.\n\n\n\n\n\n\nNoteTauchen Method\n\n\n\n\n\\(x\\) の定義域 を \\([x_{\\min}, x_{\\max}]\\) を \\(n\\) 個のグリッドポイントに分割する. 通常は \\(x\\) が従う分布の \\(3\\sigma\\) 程度の範囲を考える.\nグリッドポイント \\(x_i\\) から \\(x_j\\) に遷移する確率を以下のように定義する.\n\n\\[\n\\begin{aligned}\n\\lambda_{i, 1} &= \\Phi\\left(\\frac{x_1 + \\frac{d}{2} - (1 - \\rho) \\mu - \\rho x_i}{\\sigma}\\right) \\\\\n\\lambda_{i, j} &= \\Phi\\left(\\frac{x_j + \\frac{d}{2} - (1 - \\rho) \\mu - \\rho x_i}{\\sigma}\\right) - \\Phi\\left(\\frac{x_{j} - \\frac{d}{2} - (1 - \\rho) \\mu - \\rho x_i}{\\sigma}\\right) & (2 \\leq j \\leq n-1) \\\\\n\\lambda_{i, n} &= 1 - \\Phi\\left(\\frac{x_{n} - \\frac{d}{2} - (1 - \\rho) \\mu - \\rho x_i}{\\sigma}\\right)\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\n\n図 D.5: Visualization of Tauchen Method. \\(\\mu = 0\\).\n\n\n\n\nfunction tauchen_method(; n_std=3.0, n=5, ρ=0.9, μ=0.1, σ=1.0)\n\n    x_min = μ - n_std * sqrt(σ^2 / (1 - ρ^2))\n    x_max = μ + n_std * sqrt(σ^2 / (1 - ρ^2))\n    x = range(x_min, x_max, length=n)\n\n    d = (x_max - x_min) / (n - 1)\n    Λ = zeros(n, n)\n    for i in 1:n\n        Λ[i, 1] = cdf(Normal(0.0, σ), x[1] + d / 2 - (1 - ρ) * μ - ρ * x[i])\n        Λ[i, n] = 1 - cdf(Normal(0.0, σ), x[n] - d / 2 - (1 - ρ) * μ - ρ * x[i])\n        for j in 2:n-1\n            Λ[i, j] = cdf(Normal(0.0, σ), x[j] + d / 2 - (1 - ρ) * μ - ρ * x[i]) -\n                      cdf(Normal(0.0, σ), x[j] - d / 2 - (1 - ρ) * μ - ρ * x[i])\n        end\n    end\n\n    return x, Λ\nend\n\n\nx, Λ = tauchen_method()\n@show x\nΛ\n\nx = -6.782472016116854:3.4412360080584268:6.982472016116853\n\n\n5×5 Matrix{Float64}:\n 0.849051     0.150945     3.84556e-6  1.22125e-15  0.0\n 0.0194737    0.896192     0.0843336   7.26002e-7   1.11022e-16\n 1.22258e-7   0.04266      0.91468     0.04266      1.22258e-7\n 7.34696e-17  7.26002e-7   0.0843336   0.896192     0.0194737\n 3.45903e-30  1.23783e-15  3.84556e-6  0.150945     0.849051\n\n\n実用上は QuantEcon.jl の tauchen 関数を利用するのがいいでしょう.\n\nmc = tauchen(5, 0.9, 1.0, 0.1) # tauchen(N, ρ, σ, μ)\n@show mc.state_values\nmc.p\n\nmc.state_values = -5.8824720161168536:3.4412360080584268:7.8824720161168536\n\n\n5×5 Matrix{Float64}:\n 0.849051     0.150945     3.84556e-6  1.22125e-15  0.0\n 0.0194737    0.896192     0.0843336   7.26002e-7   1.11022e-16\n 1.22258e-7   0.04266      0.91468     0.04266      1.22258e-7\n 7.34696e-17  7.26002e-7   0.0843336   0.896192     0.0194737\n 3.45903e-30  1.23783e-15  3.84556e-6  0.150945     0.849051\n\n\nただし, ここでは AR(1) process が以下のように定義されていることに注意してください.\n\\[\ny_{t+1} = \\mu + \\rho y_{t} + \\varepsilon_{t+1}, \\quad \\varepsilon_{t+1} \\sim \\mathcal{N}(0, \\sigma^2).\n\\]\nそのため, \\(\\mathbb{E}[y_{t}] = \\frac{\\mu}{1-\\rho}\\) となります. 上の例では, \\(\\mu = 0.1\\), \\(\\rho = 0.9\\), \\(\\sigma = 1.0\\) としているため, \\(\\mathbb{E}[y_{t}] = 1.0\\) となります.\n\nps = vcat(stationary_distributions(mc)...)\nps' * collect(mc.state_values)\n\n1.0\n\n\nAR(1) processの期待値を任意の値 \\(\\tilde{\\mu}\\) に設定するためには, \\(\\mu = (1-\\rho)\\tilde{\\mu}\\) とすればよいです.\n\nmc = tauchen(5, 0.9, 1.0, 0.01)\n@show mc.state_values\nmc.p\n\nmc.state_values = -6.782472016116854:3.4412360080584268:6.982472016116853\n\n\n5×5 Matrix{Float64}:\n 0.849051     0.150945     3.84556e-6  1.22125e-15  0.0\n 0.0194737    0.896192     0.0843336   7.26002e-7   1.11022e-16\n 1.22258e-7   0.04266      0.91468     0.04266      1.22258e-7\n 7.34696e-17  7.26002e-7   0.0843336   0.896192     0.0194737\n 3.45903e-30  1.23783e-15  3.84556e-6  0.150945     0.849051\n\n\n\n\nD.3.2 Policy Function Iteration\nAR(1) process を \\(\\Lambda\\) で離散化した後のベルマン方程式は以下のようになります.\n\\[\nV(k, z) = \\max_{k'} \\left\\{u(f(k, z) + (1-\\delta)k - k') + \\beta \\sum_{z'} \\Lambda(z, z') V(k', z')\\right\\}.\n\\]\nVFIを用いる場合, 実装は価値関数 \\(V\\) の次元を \\(z\\) のために1つ増やし, ベルマン方程式の通り実装するだけです. 実装はあまり難しくありませんが, 精度があまり良くないためここでは紹介しません. 気になる場合は マクロIVの講義資料 を参考にしてください.\nPFIを用いる場合, オイラー方程式は以下のようになります.\n\\[\nu'(c) = \\beta \\sum_{z'} \\Lambda(z, z') u'(c')(f'(k', z') + (1-\\delta)).\n\\]\n\n@kwdef struct StochasticModel{TF&lt;:AbstractFloat,TI&lt;:Integer}\n    # Parameters\n    α::TF = 0.36\n    β::TF = 0.96\n    δ::TF = 0.1\n    # AR(1) process\n    ρ::TF = 0.95\n    μ::TF = 0.0\n    σ::TF = 0.05\n\n    # Policy and Value Functions\n    n_k::TI = 101\n    n_z::TI = 5\n    k_min::TF = 0.5\n    k_max::TF = 10.0\n    k_grid::Vector{TF} = collect(range(k_min, k_max, length=n_k))\n    mc::MarkovChain = tauchen(n_z, ρ, σ, μ)\n    z_grid::Vector{TF} = collect(exp.(mc.state_values))\n    Λ::Matrix{TF} = mc.p\n    V::Matrix{TF} = zeros(n_k, n_z)\n    gc::Matrix{TF} = fill(z_grid[begin] * k_min^α / 2, n_k, n_z)\n    gk::Matrix{TF} = zeros(n_k, n_z)\nend\n\nf(k, z; m::StochasticModel) = z * k^m.α\nf′(k, z; m::StochasticModel) = m.α * z * k^(m.α - 1)\n\nfunction euler_eq(c, k, i_z, gc_interp; m::StochasticModel)\n    (; β, δ, k_grid, z_grid, Λ) = m\n\n    RHS = 0.\n    for (i_z′, z′) in enumerate(z_grid)\n        k′ = max(f(k, z_grid[i_z]; m) + (1 - δ) * k - c, k_grid[begin])\n        c′ = gc_interp(k′, z′)\n        RHS += Λ[i_z, i_z′] * (u′(c′) * (f′(k′, z′; m) + 1 - δ))\n    end\n    return u′(c) - β * RHS\nend\n\nfunction pfi!(m::StochasticModel; tol=1e-6, max_iter=1000, verbose=true)\n    (; n_k, n_z, k_min, k_max, k_grid, z_grid, α, β, δ, Λ) = m\n\n    gc_new = similar(m.gc)\n\n    if all(m.gc .== 0)\n        m.gc .= f.(k_grid, z_grid'; m) .+ (1 - δ) .* k_grid .- k_grid\n        m.gc .= max.(m.gc, 1e-5)\n    end\n\n    iter, dist = 0, Inf\n    while dist &gt; tol && iter &lt; max_iter\n\n        gc_interp = linear_interpolation((k_grid, z_grid), m.gc)\n\n        for (i_k, k) in enumerate(k_grid), (i_z, z) in enumerate(z_grid)\n            c_min = max(1e-9, f(k, z; m) + (1 - δ) * k - k_grid[end])\n            c_max = f(k, z; m) + (1 - δ) * k - k_grid[begin]\n            ee_left = euler_eq(c_min, k, i_z, gc_interp; m)\n            ee_right = euler_eq(c_max, k, i_z, gc_interp; m)\n            if ee_left &gt; 0 && ee_right &gt; 0\n                gc_new[i_k, i_z] = c_max\n            elseif ee_left &lt; 0 && ee_right &lt; 0\n                gc_new[i_k, i_z] = c_min\n            else\n                gc_new[i_k, i_z] = find_zero(c -&gt; euler_eq(c, k, i_z, gc_interp; m), (c_min, c_max))\n            end\n        end\n\n        dist = maximum(abs, gc_new .- m.gc)\n        m.gc .= gc_new\n        iter += 1\n    end\n    m.gk .= f.(k_grid, z_grid'; m) .+ (1 .- δ) .* k_grid .- m.gc\n\n    if verbose\n        if iter == max_iter\n            println(\"Warning: Maximum iterations reached.\")\n        else\n            println(\"Converged in $iter iterations.\")\n        end\n    end\n\n    # Value Function\n    P = zeros(n_k * n_z, n_k * n_z)\n    for (i_k, k) in enumerate(k_grid), (i_z, z) in enumerate(z_grid)\n        g = f(k, z; m) + (1 - δ) * k - m.gc[i_k, i_z]\n        j = searchsortedlast(k_grid, g)\n        for (i_z′, z′) in enumerate(z_grid)\n            if j == 1 || j == n_k\n                P[i_k+(i_z-1)*n_k, j+(i_z′-1)*n_k] = Λ[i_z, i_z′]\n            else\n                P[i_k+(i_z-1)*n_k, j+(i_z′-1)*n_k] =\n                    Λ[i_z, i_z′] * (k_grid[j+1] - g) / (k_grid[j+1] - k_grid[j])\n                P[i_k+(i_z-1)*n_k, j+1+(i_z′-1)*n_k] =\n                    Λ[i_z, i_z′] * (g - k_grid[j]) / (k_grid[j+1] - k_grid[j])\n            end\n        end\n    end\n\n    Ṽ = (I - β * P) \\ [u(m.gc[i_k, i_z]) for i_z in 1:n_z for i_k in 1:n_k]\n    m.V .= reshape(Ṽ, n_k, n_z)\n\n    return nothing\nend\n\nm = StochasticModel()\npfi!(m)\n\nConverged in 84 iterations.\n\n\n\n\nCode\np1 = plot(m.k_grid, m.gc[:, 5], label=L\"z_5\", xlabel=L\"Capital $k$\", ylabel=L\"Consumption $c$\")\nfor i in 4:-1:1\n    plot!(m.k_grid, m.gc[:, i], label=L\"z_%$i\")\nend\np2 = plot(m.k_grid, m.gk[:, 5], label=L\"z_5\", xlabel=L\"Capital $k$\", ylabel=L\"Next Capital $k'$\")\nfor i in 4:-1:1\n    plot!(m.k_grid, m.gk[:, i], label=L\"z_%$i\")\nend\nplot(p1, p2, layout=(1, 2))\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 D.6: Policy Function Computed by Value Function Iteration (VFI) in Stochastic Case.\n\n\n\n\nここから価値関数を求めるアルゴリズムは以下のような手順になります.\n\n\\(V(k, z)\\) は離散化されたグリッド上の行列 \\(\\{V_{i_k, i_z}\\}_{i_k = 1,\\dots,n_k, i_z=1,\\dots,n_z}\\) である\n\\(\\{V_{i_k, i_z}\\}\\) をベクトル化した \\(\\widetilde{V}\\) を考える. \\(\\widetilde{V}_{i_k + n_k(i_z - 1)} := V_{i_k, i_z}\\)\nある \\(i_k, i_z\\) に対して, \\(k_{j} &lt; g_{i_k, i_z} &lt; k_{j+1}\\) を満たす \\(j \\in \\{1,\\dots,n_k\\}\\) を求める\n\\((k, z)\\) から \\((k', z')\\) への遷移は, \\(\\widetilde{V}\\) 上で \\(i_k + n_k(i_z - 1)\\) から \\(i_{k'} + n_k(i_{z'} - 1)\\) への遷移\n遷移行列 \\(P\\) は以下のように定義され, 定義されていない要素は 0 とする.\n\n\\[\n\\begin{aligned}\nP_{i_k + n_k(i_z - 1), j + n_k(i_{z'} - 1)} &= \\begin{cases}\n\\Lambda_{i_z, i_{z'}} \\frac{k_{j+1}-g_{i_k, i_z}}{k_{j+1} - k_j} & \\text{ if } 1 &lt; j &lt; n_k \\\\\n\\Lambda_{i_z, i_{z'}} & \\text{otherwise}.\n\\end{cases}\\\\\nP_{i_k + n_k(i_z - 1), j + 1 + n_k(i_{z'} - 1)} &= \\begin{cases}\n\\Lambda_{i_z, i_{z'}} \\frac{g_{i_k, i_z} - k_{j}}{k_{j+1} - k_j} & \\text{ if } 1 &lt; j &lt; n_k \\\\\n\\Lambda_{i_z, i_{z'}} & \\text{otherwise}.\n\\end{cases}\\\\\n\\end{aligned}\n\\]\n\n\nCode\np = plot(m.k_grid, m.V[:, 5], label=L\"z_5\", xlabel=L\"Capital $k$\", ylabel=L\"Value $V(k, z)$\")\nfor i in 4:-1:1\n    plot!(m.k_grid, m.V[:, i], label=L\"z_%$i\")\nend\np\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n図 D.7: Value Function Computed by Value Function Iteration (VFI) in Stochastic Case.\n\n\n\n\n\n\n\n\n\n\nStokey, Nancy L., Robert E. Lucas, and Edward C. Prescott. 1989. Recursive Methods in Economic Dynamics. Cambridge, Mass: Harvard University Press.\n\n\nTauchen, George. 1986. “Finite State Markov-Chain Approximations to Univariate and Vector Autoregressions.” Economics Letters 20 (2): 177–81. https://doi.org/10.1016/0165-1765(86)90168-0.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Dynamic Programming</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "参考文献",
    "section": "",
    "text": "Adam, Klaus, and Roberto M. Billi. 2007. “Discretionary Monetary\nPolicy and the Zero Lower Bound on Nominal Interest Rates.”\nJournal of Monetary Economics 54 (3): 728–52. https://doi.org/10.1016/j.jmoneco.2005.11.003.\n\n\nAiyagari, S. Rao. 1994. “Uninsured Idiosyncratic Risk\nand Aggregate Saving.” The Quarterly Journal of\nEconomics 109 (3): 659–84. https://doi.org/10.2307/2118417.\n\n\nAndolfatto, David. 1996. “Business Cycles and\nLabor-Market Search.” The American Economic\nReview 86 (1): 112–32. https://www.jstor.org/stable/2118258.\n\n\nAscari, Guido, and Lorenza Rossi. 2012. “Trend\nInflation and Firms\nPrice-Setting: Rotemberg Versus\nCalvo.” The Economic Journal 122 (563): 1115–41.\nhttps://doi.org/10.1111/j.1468-0297.2012.02517.x.\n\n\nAzzimonti, Marina, Per Krusell, Alisdair McKay, and Toshihiko Mukoyama.\n2025. Macroeconomics.\n\n\nBaxter, Marianne, and Robert G. King. 1999. “Measuring\nBusiness Cycles: Approximate Band-Pass Filters\nfor Economic Time Series.” The Review of\nEconomics and Statistics 81 (4): 575–93. https://www.jstor.org/stable/2646708.\n\n\nBoppart, Timo, and Per Krusell. 2020. “Labor Supply\nin the Past, Present, and Future:\nA Balanced-Growth Perspective.” Journal of\nPolitical Economy 128 (1): 118–57. https://doi.org/10.1086/704071.\n\n\nBullard, James, and Kaushik Mitra. 2002. “Learning about Monetary\nPolicy Rules.” Journal of Monetary Economics 49 (6):\n1105–29. https://doi.org/10.1016/S0304-3932(02)00144-7.\n\n\nCalvo, Guillermo A. 1983. “Staggered Prices in a\nUtility-Maximizing Framework.” Journal of Monetary\nEconomics 12 (3): 383–98. https://doi.org/10.1016/0304-3932(83)90060-0.\n\n\nChetty, Raj, Adam Guren, Day Manoli, and Andrea Weber. 2011. “Are\nMicro and Macro Labor Supply Elasticities\nConsistent? A Review of Evidence on the\nIntensive and Extensive Margins.”\nAmerican Economic Review 101 (3): 471–75. https://doi.org/10.1257/aer.101.3.471.\n\n\nCooley, Thomas F., and Edward C. Prescott. 1995. “Economic\nGrowth and Business Cycles.” In\nFrontiers of Business Cycle Research, edited by\nThomas F. Cooley, 1–38. Princeton University Press. https://doi.org/10.2307/j.ctv14163jx.7.\n\n\nErosa, Andrés, Luisa Fuster, and Gueorgui Kambourov. 2016.\n“Towards a Micro-Founded Theory of Aggregate\nLabour Supply.” The Review of Economic Studies 83\n(3): 1001–39. https://doi.org/10.1093/restud/rdw010.\n\n\nGalí, Jordi. 2015. Monetary Policy, Inflation, and the Business\nCycle: An Introduction to the New Keynesian Framework and\nIts Applications. Second edition. Princeton Oxford: Princeton\nUniversity Press.\n\n\nGoldberg, Pinelopi, and Rebecca Hellerstein. 2007. “Sticky Prices:\nWhy Firms Hesitate to Adjust the Price of Their Goods.”\nCurrent Issues in Economics and Finance 13 (10).\n\n\nHagedorn, Marcus, and Iourii Manovskii. 2008. “The Cyclical\nBehavior of Equilibrium Unemployment and\nVacancies Revisited.” American Economic\nReview 98 (4): 1692–1706. https://doi.org/10.1257/aer.98.4.1692.\n\n\nKarabarbounis, Loukas, and Brent Neiman. 2014. “The Global\nDecline of the Labor Share.” The\nQuarterly Journal of Economics 129 (1): 61–103. https://doi.org/10.1093/qje/qjt032.\n\n\nKing, Robert G., Charles I. Plosser, and Sergio T. Rebelo. 1988.\n“Production, Growth and Business Cycles: I.\nThe Basic Neoclassical Model.” Journal of\nMonetary Economics 21 (2): 195–232. https://doi.org/10.1016/0304-3932(88)90030-X.\n\n\nKrusell, Per, Toshihiko Mukoyama, and Ayşegül Şahin. 2010.\n“Labour-Market Matching with Precautionary\nSavings and Aggregate Fluctuations.”\nReview of Economic Studies 77 (4): 1477–507. https://doi.org/10.1111/j.1467-937X.2010.00700.x.\n\n\nKydland, Finn E., and Edward C. Prescott. 1982. “Time to\nBuild and Aggregate Fluctuations.”\nEconometrica 50 (6): 1345–70. https://doi.org/10.2307/1913386.\n\n\nLucas, Robert E. 1977. “Understanding Business Cycles.”\nCarnegie-Rochester Conference Series on Public Policy 5\n(January): 7–29. https://doi.org/10.1016/0167-2231(77)90002-1.\n\n\nMerz, Monika. 1995. “Search in the Labor Market and the Real\nBusiness Cycle.” Journal of Monetary Economics 36 (2):\n269–300. https://doi.org/10.1016/0304-3932(95)01216-8.\n\n\nMüller, Karsten, Chenzi Xu, Mohamed Lehbib, and Ziliang Chen. 2025.\n“The Global Macro Database: A New International Macroeconomic\nDataset.”\n\n\nPrescott, Edward C. 1986. “Theory Ahead of\nBusiness Cycle Measurement.” Quarterly\nReview 10 (4). https://doi.org/10.21034/qr.1042.\n\n\nRotemberg, Julio J. 1982. “Sticky Prices in the\nUnited States.” Journal of Political\nEconomy 90 (6): 1187–1211. https://doi.org/10.1086/261117.\n\n\nShimer, Robert. 2005. “The Cyclical Behavior of\nEquilibrium Unemployment and\nVacancies.” American Economic Review 95\n(1): 25–49. https://doi.org/10.1257/0002828053828572.\n\n\nStokey, Nancy L., Robert E. Lucas, and Edward C. Prescott. 1989.\nRecursive Methods in Economic Dynamics. Cambridge, Mass:\nHarvard University Press.\n\n\nTauchen, George. 1986. “Finite State Markov-Chain Approximations\nto Univariate and Vector Autoregressions.” Economics\nLetters 20 (2): 177–81. https://doi.org/10.1016/0165-1765(86)90168-0.\n\n\nTaylor, John B. 1993. “Discretion Versus Policy Rules in\nPractice.” Carnegie-Rochester Conference Series on Public\nPolicy 39 (December): 195–214. https://doi.org/10.1016/0167-2231(93)90009-L.\n\n\n北尾早霧, 砂川武貴, and 山田知明. 2024.\n定量的マクロ経済学と数値計算. 日本評論社.",
    "crumbs": [
      "Appendices",
      "参考文献"
    ]
  }
]